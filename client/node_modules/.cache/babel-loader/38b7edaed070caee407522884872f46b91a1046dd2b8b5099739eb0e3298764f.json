{"ast":null,"code":"import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { getDefaultProxySettings } from \"@azure/core-rest-pipeline\";\nimport { isNode } from \"@azure/core-util\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { ContainerClient } from \"./ContainerClient\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, toTags } from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { truncatedISO8061Date, assertResponse } from \"./utils/utils.common\";\nimport { tracingClient } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport { generateAccountSASQueryParameters, generateAccountSASQueryParametersInternal } from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\nexport class BlobServiceClient extends StorageClient {\n  /**\n   *\n   * Creates an instance of BlobServiceClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  static fromConnectionString(connectionString,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    options = options || {};\n    const extractedCreds = extractConnectionStringParts(connectionString);\n    if (extractedCreds.kind === \"AccountConnString\") {\n      if (isNode) {\n        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n        if (!options.proxyOptions) {\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n        }\n        const pipeline = newPipeline(sharedKeyCredential, options);\n        return new BlobServiceClient(extractedCreds.url, pipeline);\n      } else {\n        throw new Error(\"Account connection string is only supported in Node.js environment\");\n      }\n    } else if (extractedCreds.kind === \"SASConnString\") {\n      const pipeline = newPipeline(new AnonymousCredential(), options);\n      return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, pipeline);\n    } else {\n      throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n    }\n  }\n  constructor(url, credentialOrPipeline,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    let pipeline;\n    if (isPipelineLike(credentialOrPipeline)) {\n      pipeline = credentialOrPipeline;\n    } else if (isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || isTokenCredential(credentialOrPipeline)) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n    super(url, pipeline);\n    this.serviceContext = this.storageClientContext.service;\n  }\n  /**\n   * Creates a {@link ContainerClient} object\n   *\n   * @param containerName - A container name\n   * @returns A new ContainerClient object for the given container name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * ```\n   */\n  getContainerClient(containerName) {\n    return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);\n  }\n  /**\n   * Create a Blob container. @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param containerName - Name of the container to create.\n   * @param options - Options to configure Container Create operation.\n   * @returns Container creation response and the corresponding container client.\n   */\n  async createContainer(containerName, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-createContainer\", options, async updatedOptions => {\n      const containerClient = this.getContainerClient(containerName);\n      const containerCreateResponse = await containerClient.create(updatedOptions);\n      return {\n        containerClient,\n        containerCreateResponse\n      };\n    });\n  }\n  /**\n   * Deletes a Blob container.\n   *\n   * @param containerName - Name of the container to delete.\n   * @param options - Options to configure Container Delete operation.\n   * @returns Container deletion response.\n   */\n  async deleteContainer(containerName, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-deleteContainer\", options, async updatedOptions => {\n      const containerClient = this.getContainerClient(containerName);\n      return containerClient.delete(updatedOptions);\n    });\n  }\n  /**\n   * Restore a previously deleted Blob container.\n   * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n   *\n   * @param deletedContainerName - Name of the previously deleted container.\n   * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n   * @param options - Options to configure Container Restore operation.\n   * @returns Container deletion response.\n   */\n  async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-undeleteContainer\", options, async updatedOptions => {\n      const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName);\n      // Hack to access a protected member.\n      const containerContext = containerClient[\"storageClientContext\"].container;\n      const containerUndeleteResponse = assertResponse(await containerContext.restore({\n        deletedContainerName,\n        deletedContainerVersion,\n        tracingOptions: updatedOptions.tracingOptions\n      }));\n      return {\n        containerClient,\n        containerUndeleteResponse\n      };\n    });\n  }\n  /**\n   * Rename an existing Blob Container.\n   *\n   * @param sourceContainerName - The name of the source container.\n   * @param destinationContainerName - The new name of the container.\n   * @param options - Options to configure Container Rename operation.\n   */\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n  async renameContainer(sourceContainerName, destinationContainerName, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-renameContainer\", options, async updatedOptions => {\n      var _a;\n      const containerClient = this.getContainerClient(destinationContainerName);\n      // Hack to access a protected member.\n      const containerContext = containerClient[\"storageClientContext\"].container;\n      const containerRenameResponse = assertResponse(await containerContext.rename(sourceContainerName, Object.assign(Object.assign({}, updatedOptions), {\n        sourceLeaseId: (_a = options.sourceCondition) === null || _a === void 0 ? void 0 : _a.leaseId\n      })));\n      return {\n        containerClient,\n        containerRenameResponse\n      };\n    });\n  }\n  /**\n   * Gets the properties of a storage account’s Blob service, including properties\n   * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * @param options - Options to the Service Get Properties operation.\n   * @returns Response data for the Service Get Properties operation.\n   */\n  async getProperties(options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-getProperties\", options, async updatedOptions => {\n      return assertResponse(await this.serviceContext.getProperties({\n        abortSignal: options.abortSignal,\n        tracingOptions: updatedOptions.tracingOptions\n      }));\n    });\n  }\n  /**\n   * Sets properties for a storage account’s Blob service endpoint, including properties\n   * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n   *\n   * @param properties -\n   * @param options - Options to the Service Set Properties operation.\n   * @returns Response data for the Service Set Properties operation.\n   */\n  async setProperties(properties, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-setProperties\", options, async updatedOptions => {\n      return assertResponse(await this.serviceContext.setProperties(properties, {\n        abortSignal: options.abortSignal,\n        tracingOptions: updatedOptions.tracingOptions\n      }));\n    });\n  }\n  /**\n   * Retrieves statistics related to replication for the Blob service. It is only\n   * available on the secondary location endpoint when read-access geo-redundant\n   * replication is enabled for the storage account.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n   *\n   * @param options - Options to the Service Get Statistics operation.\n   * @returns Response data for the Service Get Statistics operation.\n   */\n  async getStatistics(options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-getStatistics\", options, async updatedOptions => {\n      return assertResponse(await this.serviceContext.getStatistics({\n        abortSignal: options.abortSignal,\n        tracingOptions: updatedOptions.tracingOptions\n      }));\n    });\n  }\n  /**\n   * The Get Account Information operation returns the sku name and account kind\n   * for the specified account.\n   * The Get Account Information operation is available on service versions beginning\n   * with version 2018-03-28.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-account-information\n   *\n   * @param options - Options to the Service Get Account Info operation.\n   * @returns Response data for the Service Get Account Info operation.\n   */\n  async getAccountInfo(options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-getAccountInfo\", options, async updatedOptions => {\n      return assertResponse(await this.serviceContext.getAccountInfo({\n        abortSignal: options.abortSignal,\n        tracingOptions: updatedOptions.tracingOptions\n      }));\n    });\n  }\n  /**\n   * Returns a list of the containers under the specified account.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/list-containers2\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to the Service List Container Segment operation.\n   * @returns Response data for the Service List Container Segment operation.\n   */\n  async listContainersSegment(marker, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-listContainersSegment\", options, async updatedOptions => {\n      return assertResponse(await this.serviceContext.listContainersSegment(Object.assign(Object.assign({\n        abortSignal: options.abortSignal,\n        marker\n      }, options), {\n        include: typeof options.include === \"string\" ? [options.include] : options.include,\n        tracingOptions: updatedOptions.tracingOptions\n      })));\n    });\n  }\n  /**\n   * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n   * match a given search expression. Filter blobs searches across all containers within a\n   * storage account but can be scoped within the expression to a single container.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-findBlobsByTagsSegment\", options, async updatedOptions => {\n      const response = assertResponse(await this.serviceContext.filterBlobs({\n        abortSignal: options.abortSignal,\n        where: tagFilterSqlExpression,\n        marker,\n        maxPageSize: options.maxPageSize,\n        tracingOptions: updatedOptions.tracingOptions\n      }));\n      const wrappedResponse = Object.assign(Object.assign({}, response), {\n        _response: response._response,\n        blobs: response.blobs.map(blob => {\n          var _a;\n          let tagValue = \"\";\n          if (((_a = blob.tags) === null || _a === void 0 ? void 0 : _a.blobTagSet.length) === 1) {\n            tagValue = blob.tags.blobTagSet[0].value;\n          }\n          return Object.assign(Object.assign({}, blob), {\n            tags: toTags(blob.tags),\n            tagValue\n          });\n        })\n      });\n      return wrappedResponse;\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  findBlobsByTagsSegments(tagFilterSqlExpression_1, marker_1) {\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1(tagFilterSqlExpression, marker, options = {}) {\n      let response;\n      if (!!marker || marker === undefined) {\n        do {\n          response = yield __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));\n          response.blobs = response.blobs || [];\n          marker = response.continuationToken;\n          yield yield __await(response);\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n  findBlobsByTagsItems(tagFilterSqlExpression_1) {\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsItems_1(tagFilterSqlExpression, options = {}) {\n      var _a, e_1, _b, _c;\n      let marker;\n      try {\n        for (var _d = true, _e = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const segment = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(segment.blobs)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n  findBlobsByTags(tagFilterSqlExpression, options = {}) {\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions = Object.assign({}, options);\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }\n    };\n  }\n  /**\n   * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to list containers operation.\n   */\n  listSegments(marker_1) {\n    return __asyncGenerator(this, arguments, function* listSegments_1(marker, options = {}) {\n      let listContainersSegmentResponse;\n      if (!!marker || marker === undefined) {\n        do {\n          listContainersSegmentResponse = yield __await(this.listContainersSegment(marker, options));\n          listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];\n          marker = listContainersSegmentResponse.continuationToken;\n          yield yield __await(yield __await(listContainersSegmentResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for Container Items\n   *\n   * @param options - Options to list containers operation.\n   */\n  listItems() {\n    return __asyncGenerator(this, arguments, function* listItems_1(options = {}) {\n      var _a, e_2, _b, _c;\n      let marker;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listSegments(marker, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const segment = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(segment.containerItems)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list all the containers\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the containers in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const container of blobServiceClient.listContainers()) {\n   *   console.log(`Container ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.listContainers();\n   * let containerItem = await iter.next();\n   * while (!containerItem.done) {\n   *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n   *   containerItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n   *   if (response.containerItems) {\n   *     for (const container of response.containerItems) {\n   *       console.log(`Container ${i++}: ${container.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *     console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .listContainers()\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *      console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param options - Options to list containers.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  listContainers(options = {}) {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n    const include = [];\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n    if (options.includeSystem) {\n      include.push(\"system\");\n    }\n    // AsyncIterableIterator to iterate over containers\n    const listSegmentOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n      include\n    } : {});\n    const iter = this.listItems(listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listSegments(settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }\n    };\n  }\n  /**\n   * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n   *\n   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n   * bearer token authentication.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n   *\n   * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n   * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n   */\n  async getUserDelegationKey(startsOn, expiresOn, options = {}) {\n    return tracingClient.withSpan(\"BlobServiceClient-getUserDelegationKey\", options, async updatedOptions => {\n      const response = assertResponse(await this.serviceContext.getUserDelegationKey({\n        startsOn: truncatedISO8061Date(startsOn, false),\n        expiresOn: truncatedISO8061Date(expiresOn, false)\n      }, {\n        abortSignal: options.abortSignal,\n        tracingOptions: updatedOptions.tracingOptions\n      }));\n      const userDelegationKey = {\n        signedObjectId: response.signedObjectId,\n        signedTenantId: response.signedTenantId,\n        signedStartsOn: new Date(response.signedStartsOn),\n        signedExpiresOn: new Date(response.signedExpiresOn),\n        signedService: response.signedService,\n        signedVersion: response.signedVersion,\n        value: response.value\n      };\n      const res = Object.assign({\n        _response: response._response,\n        requestId: response.requestId,\n        clientRequestId: response.clientRequestId,\n        version: response.version,\n        date: response.date,\n        errorCode: response.errorCode\n      }, userDelegationKey);\n      return res;\n    });\n  }\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this service.\n   */\n  getBlobBatchClient() {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions.parse(\"r\"), resourceTypes = \"sco\", options = {}) {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\"Can only generate the account SAS when the client is initialized with a shared key credential\");\n    }\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n    const sas = generateAccountSASQueryParameters(Object.assign({\n      permissions,\n      expiresOn,\n      resourceTypes,\n      services: AccountSASServices.parse(\"b\").toString()\n    }, options), this.credential).toString();\n    return appendToURLQuery(this.url, sas);\n  }\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates string to sign for a Blob account Shared Access Signature (SAS) URI based on\n   * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  generateSasStringToSign(expiresOn, permissions = AccountSASPermissions.parse(\"r\"), resourceTypes = \"sco\", options = {}) {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\"Can only generate the account SAS when the client is initialized with a shared key credential\");\n    }\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n    return generateAccountSASQueryParametersInternal(Object.assign({\n      permissions,\n      expiresOn,\n      resourceTypes,\n      services: AccountSASServices.parse(\"b\").toString()\n    }, options), this.credential).stringToSign;\n  }\n}","map":{"version":3,"names":["isTokenCredential","getDefaultProxySettings","isNode","newPipeline","isPipelineLike","ContainerClient","appendToURLPath","appendToURLQuery","extractConnectionStringParts","toTags","StorageSharedKeyCredential","AnonymousCredential","truncatedISO8061Date","assertResponse","tracingClient","BlobBatchClient","StorageClient","AccountSASPermissions","generateAccountSASQueryParameters","generateAccountSASQueryParametersInternal","AccountSASServices","BlobServiceClient","fromConnectionString","connectionString","options","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","proxyOptions","proxyUri","pipeline","url","Error","accountSas","constructor","credentialOrPipeline","serviceContext","storageClientContext","service","getContainerClient","containerName","encodeURIComponent","createContainer","withSpan","updatedOptions","containerClient","containerCreateResponse","create","deleteContainer","delete","undeleteContainer","deletedContainerName","deletedContainerVersion","destinationContainerName","containerContext","container","containerUndeleteResponse","restore","tracingOptions","renameContainer","sourceContainerName","containerRenameResponse","rename","Object","assign","sourceLeaseId","_a","sourceCondition","leaseId","getProperties","abortSignal","setProperties","properties","getStatistics","getAccountInfo","listContainersSegment","marker","include","findBlobsByTagsSegment","tagFilterSqlExpression","response","filterBlobs","where","maxPageSize","wrappedResponse","_response","blobs","map","blob","tagValue","tags","blobTagSet","length","value","findBlobsByTagsSegments","tagFilterSqlExpression_1","marker_1","undefined","__await","continuationToken","findBlobsByTagsItems","_d","_e","__asyncValues","_f","next","done","_c","segment","__asyncDelegator","findBlobsByTags","listSegmentOptions","iter","Symbol","asyncIterator","byPage","settings","listSegments","listContainersSegmentResponse","containerItems","listItems","listContainers","prefix","includeDeleted","push","includeMetadata","includeSystem","getUserDelegationKey","startsOn","expiresOn","userDelegationKey","signedObjectId","signedTenantId","signedStartsOn","Date","signedExpiresOn","signedService","signedVersion","res","requestId","clientRequestId","version","date","errorCode","getBlobBatchClient","generateAccountSasUrl","permissions","parse","resourceTypes","credential","RangeError","now","getTime","sas","services","toString","generateSasStringToSign","stringToSign"],"sources":["C:\\Users\\rdpro\\Projects\\NW Michigan Watershed Coalition\\client\\node_modules\\@azure\\storage-blob\\src\\BlobServiceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { getDefaultProxySettings } from \"@azure/core-rest-pipeline\";\nimport { isNode } from \"@azure/core-util\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport type {\n  ServiceGetUserDelegationKeyHeaders,\n  ContainerCreateResponse,\n  ContainerDeleteResponse,\n  ServiceGetPropertiesResponse,\n  BlobServiceProperties,\n  ServiceSetPropertiesResponse,\n  ServiceGetStatisticsResponse,\n  ServiceGetAccountInfoResponse,\n  ServiceListContainersSegmentResponse,\n  ContainerItem,\n  UserDelegationKeyModel,\n  ContainerUndeleteResponse,\n  FilterBlobSegmentModel,\n  ServiceFilterBlobsHeaders,\n  ContainerRenameResponse,\n  LeaseAccessConditions,\n  FilterBlobSegment,\n  FilterBlobItem,\n  ServiceGetPropertiesResponseInternal,\n  ServiceGetStatisticsResponseInternal,\n  ServiceListContainersSegmentResponseInternal,\n} from \"./generatedModels\";\nimport type { Service } from \"./generated/src/operationsInterfaces\";\nimport type { StoragePipelineOptions, PipelineLike } from \"./Pipeline\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport type { ContainerCreateOptions, ContainerDeleteMethodOptions } from \"./ContainerClient\";\nimport { ContainerClient } from \"./ContainerClient\";\nimport type { WithResponse } from \"./utils/utils.common\";\nimport {\n  appendToURLPath,\n  appendToURLQuery,\n  extractConnectionStringParts,\n  toTags,\n} from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport type { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { truncatedISO8061Date, assertResponse } from \"./utils/utils.common\";\nimport { tracingClient } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport type { CommonOptions } from \"./StorageClient\";\nimport { StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport type { SASProtocol } from \"./sas/SASQueryParameters\";\nimport type { SasIPRange } from \"./sas/SasIPRange\";\nimport {\n  generateAccountSASQueryParameters,\n  generateAccountSASQueryParametersInternal,\n} from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\nimport type {\n  ContainerRenameHeaders,\n  ContainerRestoreHeaders,\n  ListContainersIncludeType,\n  ServiceFilterBlobsResponse,\n  ServiceGetAccountInfoHeaders,\n  ServiceGetPropertiesHeaders,\n  ServiceGetStatisticsHeaders,\n  ServiceGetUserDelegationKeyResponse as ServiceGetUserDelegationKeyResponseModel,\n  ServiceListContainersSegmentHeaders,\n  ServiceSetPropertiesHeaders,\n} from \"./generated/src\";\n\n/**\n * Options to configure the {@link BlobServiceClient.getProperties} operation.\n */\nexport interface ServiceGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.setProperties} operation.\n */\nexport interface ServiceSetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.getAccountInfo} operation.\n */\nexport interface ServiceGetAccountInfoOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.getStatistics} operation.\n */\nexport interface ServiceGetStatisticsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the Service - Get User Delegation Key.\n */\nexport interface ServiceGetUserDelegationKeyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.listContainerSegment} operation.\n */\ninterface ServiceListContainersSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n  /**\n   * Specifies the maximum number of containers\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n  /**\n   * Include this parameter to\n   * specify that the container's metadata be returned as part of the response\n   * body. Possible values include: 'metadata'\n   */\n  include?: ListContainersIncludeType | ListContainersIncludeType[];\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.listContainers} operation.\n */\nexport interface ServiceListContainersOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n  /**\n   * Specifies whether the container's metadata\n   *                                   should be returned as part of the response body.\n   */\n  includeMetadata?: boolean;\n\n  /**\n   * Specifies whether soft deleted containers should be included in the response.\n   */\n  includeDeleted?: boolean;\n  /**\n   * Specifies whether system containers should be included in the response.\n   */\n  includeSystem?: boolean;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.findBlobsByTagsSegment} operation.\n */\ninterface ServiceFindBlobsByTagsSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of blobs\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport interface ServiceFindBlobByTagsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The response of {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport type ServiceFindBlobsByTagsSegmentResponse = WithResponse<\n  FilterBlobSegment & ServiceFilterBlobsHeaders,\n  ServiceFilterBlobsHeaders,\n  FilterBlobSegmentModel\n>;\n\n/**\n * A user delegation key.\n */\nexport interface UserDelegationKey {\n  /**\n   * The Azure Active Directory object ID in GUID format.\n   */\n  signedObjectId: string;\n  /**\n   * The Azure Active Directory tenant ID in GUID format.\n   */\n  signedTenantId: string;\n  /**\n   * The date-time the key is active.\n   */\n  signedStartsOn: Date;\n  /**\n   * The date-time the key expires.\n   */\n  signedExpiresOn: Date;\n  /**\n   * Abbreviation of the Azure Storage service that accepts the key.\n   */\n  signedService: string;\n  /**\n   * The service version that created the key.\n   */\n  signedVersion: string;\n  /**\n   * The key as a base64 string.\n   */\n  value: string;\n}\n\n/**\n * Contains response data for the {@link getUserDelegationKey} operation.\n */\nexport declare type ServiceGetUserDelegationKeyResponse = WithResponse<\n  UserDelegationKey & ServiceGetUserDelegationKeyHeaders,\n  ServiceGetUserDelegationKeyHeaders,\n  UserDelegationKeyModel\n>;\n\n/**\n * Options to configure {@link BlobServiceClient.undeleteContainer} operation.\n */\nexport interface ServiceUndeleteContainerOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. Specifies the new name of the restored container.\n   * Will use its original name if this is not specified.\n   * @deprecated Restore container to a different name is not supported by service anymore.\n   */\n  destinationContainerName?: string;\n}\n\n/**\n * Options to configure {@link BlobServiceClient.renameContainer} operation.\n */\nexport interface ServiceRenameContainerOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Condition to meet for the source container.\n   */\n  sourceCondition?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure {@link BlobServiceClient.generateAccountSasUrl} operation.\n */\nexport interface ServiceGenerateAccountSasUrlOptions {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols allowed.\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n  /**\n   * Optional. IP range allowed.\n   */\n  ipRange?: SasIPRange;\n  /**\n   * Optional. Encryption scope to use when sending requests authorized with this SAS URI.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\nexport class BlobServiceClient extends StorageClient {\n  /**\n   * serviceContext provided by protocol layer.\n   */\n  private serviceContext: Service;\n\n  /**\n   *\n   * Creates an instance of BlobServiceClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  public static fromConnectionString(\n    connectionString: string,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions,\n  ): BlobServiceClient {\n    options = options || {};\n    const extractedCreds = extractConnectionStringParts(connectionString);\n    if (extractedCreds.kind === \"AccountConnString\") {\n      if (isNode) {\n        const sharedKeyCredential = new StorageSharedKeyCredential(\n          extractedCreds.accountName!,\n          extractedCreds.accountKey,\n        );\n\n        if (!options.proxyOptions) {\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n        }\n\n        const pipeline = newPipeline(sharedKeyCredential, options);\n        return new BlobServiceClient(extractedCreds.url, pipeline);\n      } else {\n        throw new Error(\"Account connection string is only supported in Node.js environment\");\n      }\n    } else if (extractedCreds.kind === \"SASConnString\") {\n      const pipeline = newPipeline(new AnonymousCredential(), options);\n      return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, pipeline);\n    } else {\n      throw new Error(\n        \"Connection string must be either an Account connection string or a SAS connection string\",\n      );\n    }\n  }\n\n  /**\n   * Creates an instance of BlobServiceClient.\n   *\n   * @param url - A Client string pointing to Azure Storage blob service, such as\n   *                     \"https://myaccount.blob.core.windows.net\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net?sasString\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   *\n   * Example using DefaultAzureCredential from `@azure/identity`:\n   *\n   * ```js\n   * const account = \"<storage account name>\";\n   *\n   * const defaultAzureCredential = new DefaultAzureCredential();\n   *\n   * const blobServiceClient = new BlobServiceClient(\n   *   `https://${account}.blob.core.windows.net`,\n   *   defaultAzureCredential\n   * );\n   * ```\n   *\n   * Example using an account name/key:\n   *\n   * ```js\n   * const account = \"<storage account name>\"\n   * const sharedKeyCredential = new StorageSharedKeyCredential(account, \"<account key>\");\n   *\n   * const blobServiceClient = new BlobServiceClient(\n   *   `https://${account}.blob.core.windows.net`,\n   *   sharedKeyCredential\n   * );\n   * ```\n   */\n  constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions,\n  );\n  /**\n   * Creates an instance of BlobServiceClient.\n   *\n   * @param url - A Client string pointing to Azure Storage blob service, such as\n   *                     \"https://myaccount.blob.core.windows.net\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    url: string,\n    credentialOrPipeline?:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions,\n  ) {\n    let pipeline: PipelineLike;\n    if (isPipelineLike(credentialOrPipeline)) {\n      pipeline = credentialOrPipeline;\n    } else if (\n      (isNode && credentialOrPipeline instanceof StorageSharedKeyCredential) ||\n      credentialOrPipeline instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipeline)\n    ) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n    super(url, pipeline);\n    this.serviceContext = this.storageClientContext.service;\n  }\n\n  /**\n   * Creates a {@link ContainerClient} object\n   *\n   * @param containerName - A container name\n   * @returns A new ContainerClient object for the given container name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * ```\n   */\n  public getContainerClient(containerName: string): ContainerClient {\n    return new ContainerClient(\n      appendToURLPath(this.url, encodeURIComponent(containerName)),\n      this.pipeline,\n    );\n  }\n\n  /**\n   * Create a Blob container. @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param containerName - Name of the container to create.\n   * @param options - Options to configure Container Create operation.\n   * @returns Container creation response and the corresponding container client.\n   */\n  public async createContainer(\n    containerName: string,\n    options: ContainerCreateOptions = {},\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerCreateResponse: ContainerCreateResponse;\n  }> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-createContainer\",\n      options,\n      async (updatedOptions) => {\n        const containerClient = this.getContainerClient(containerName);\n        const containerCreateResponse = await containerClient.create(updatedOptions);\n        return {\n          containerClient,\n          containerCreateResponse,\n        };\n      },\n    );\n  }\n\n  /**\n   * Deletes a Blob container.\n   *\n   * @param containerName - Name of the container to delete.\n   * @param options - Options to configure Container Delete operation.\n   * @returns Container deletion response.\n   */\n  public async deleteContainer(\n    containerName: string,\n    options: ContainerDeleteMethodOptions = {},\n  ): Promise<ContainerDeleteResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-deleteContainer\",\n      options,\n      async (updatedOptions) => {\n        const containerClient = this.getContainerClient(containerName);\n        return containerClient.delete(updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Restore a previously deleted Blob container.\n   * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n   *\n   * @param deletedContainerName - Name of the previously deleted container.\n   * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n   * @param options - Options to configure Container Restore operation.\n   * @returns Container deletion response.\n   */\n  public async undeleteContainer(\n    deletedContainerName: string,\n    deletedContainerVersion: string,\n    options: ServiceUndeleteContainerOptions = {},\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerUndeleteResponse: ContainerUndeleteResponse;\n  }> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-undeleteContainer\",\n      options,\n      async (updatedOptions) => {\n        const containerClient = this.getContainerClient(\n          options.destinationContainerName || deletedContainerName,\n        );\n        // Hack to access a protected member.\n        const containerContext = containerClient[\"storageClientContext\"].container;\n        const containerUndeleteResponse = assertResponse<\n          ContainerRestoreHeaders,\n          ContainerRestoreHeaders\n        >(\n          await containerContext.restore({\n            deletedContainerName,\n            deletedContainerVersion,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n        return { containerClient, containerUndeleteResponse };\n      },\n    );\n  }\n\n  /**\n   * Rename an existing Blob Container.\n   *\n   * @param sourceContainerName - The name of the source container.\n   * @param destinationContainerName - The new name of the container.\n   * @param options - Options to configure Container Rename operation.\n   */\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n  private async renameContainer(\n    sourceContainerName: string,\n    destinationContainerName: string,\n    options: ServiceRenameContainerOptions = {},\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerRenameResponse: ContainerRenameResponse;\n  }> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-renameContainer\",\n      options,\n      async (updatedOptions) => {\n        const containerClient = this.getContainerClient(destinationContainerName);\n        // Hack to access a protected member.\n        const containerContext = containerClient[\"storageClientContext\"].container;\n        const containerRenameResponse = assertResponse<\n          ContainerRenameHeaders,\n          ContainerRenameHeaders\n        >(\n          await containerContext.rename(sourceContainerName, {\n            ...updatedOptions,\n            sourceLeaseId: options.sourceCondition?.leaseId,\n          }),\n        );\n        return { containerClient, containerRenameResponse };\n      },\n    );\n  }\n\n  /**\n   * Gets the properties of a storage account’s Blob service, including properties\n   * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * @param options - Options to the Service Get Properties operation.\n   * @returns Response data for the Service Get Properties operation.\n   */\n  public async getProperties(\n    options: ServiceGetPropertiesOptions = {},\n  ): Promise<ServiceGetPropertiesResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-getProperties\",\n      options,\n      async (updatedOptions) => {\n        return assertResponse<ServiceGetPropertiesResponseInternal, ServiceGetPropertiesHeaders>(\n          await this.serviceContext.getProperties({\n            abortSignal: options.abortSignal,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * Sets properties for a storage account’s Blob service endpoint, including properties\n   * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n   *\n   * @param properties -\n   * @param options - Options to the Service Set Properties operation.\n   * @returns Response data for the Service Set Properties operation.\n   */\n  public async setProperties(\n    properties: BlobServiceProperties,\n    options: ServiceSetPropertiesOptions = {},\n  ): Promise<ServiceSetPropertiesResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-setProperties\",\n      options,\n      async (updatedOptions) => {\n        return assertResponse<ServiceSetPropertiesHeaders, ServiceSetPropertiesHeaders>(\n          await this.serviceContext.setProperties(properties, {\n            abortSignal: options.abortSignal,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * Retrieves statistics related to replication for the Blob service. It is only\n   * available on the secondary location endpoint when read-access geo-redundant\n   * replication is enabled for the storage account.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n   *\n   * @param options - Options to the Service Get Statistics operation.\n   * @returns Response data for the Service Get Statistics operation.\n   */\n  public async getStatistics(\n    options: ServiceGetStatisticsOptions = {},\n  ): Promise<ServiceGetStatisticsResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-getStatistics\",\n      options,\n      async (updatedOptions) => {\n        return assertResponse<ServiceGetStatisticsResponseInternal, ServiceGetStatisticsHeaders>(\n          await this.serviceContext.getStatistics({\n            abortSignal: options.abortSignal,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * The Get Account Information operation returns the sku name and account kind\n   * for the specified account.\n   * The Get Account Information operation is available on service versions beginning\n   * with version 2018-03-28.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-account-information\n   *\n   * @param options - Options to the Service Get Account Info operation.\n   * @returns Response data for the Service Get Account Info operation.\n   */\n  public async getAccountInfo(\n    options: ServiceGetAccountInfoOptions = {},\n  ): Promise<ServiceGetAccountInfoResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-getAccountInfo\",\n      options,\n      async (updatedOptions) => {\n        return assertResponse<ServiceGetAccountInfoHeaders, ServiceGetAccountInfoHeaders>(\n          await this.serviceContext.getAccountInfo({\n            abortSignal: options.abortSignal,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * Returns a list of the containers under the specified account.\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/list-containers2\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to the Service List Container Segment operation.\n   * @returns Response data for the Service List Container Segment operation.\n   */\n  private async listContainersSegment(\n    marker?: string,\n    options: ServiceListContainersSegmentOptions = {},\n  ): Promise<ServiceListContainersSegmentResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-listContainersSegment\",\n      options,\n      async (updatedOptions) => {\n        return assertResponse<\n          ServiceListContainersSegmentResponseInternal,\n          ServiceListContainersSegmentHeaders\n        >(\n          await this.serviceContext.listContainersSegment({\n            abortSignal: options.abortSignal,\n            marker,\n            ...options,\n            include: typeof options.include === \"string\" ? [options.include] : options.include,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n   * match a given search expression. Filter blobs searches across all containers within a\n   * storage account but can be scoped within the expression to a single container.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async findBlobsByTagsSegment(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {},\n  ): Promise<ServiceFindBlobsByTagsSegmentResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-findBlobsByTagsSegment\",\n      options,\n      async (updatedOptions) => {\n        const response = assertResponse<\n          ServiceFilterBlobsResponse,\n          ServiceFilterBlobsHeaders,\n          FilterBlobSegmentModel\n        >(\n          await this.serviceContext.filterBlobs({\n            abortSignal: options.abortSignal,\n            where: tagFilterSqlExpression,\n            marker,\n            maxPageSize: options.maxPageSize,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n\n        const wrappedResponse: ServiceFindBlobsByTagsSegmentResponse = {\n          ...response,\n          _response: response._response, // _response is made non-enumerable\n          blobs: response.blobs.map((blob) => {\n            let tagValue = \"\";\n            if (blob.tags?.blobTagSet.length === 1) {\n              tagValue = blob.tags.blobTagSet[0].value;\n            }\n            return { ...blob, tags: toTags(blob.tags), tagValue };\n          }),\n        };\n        return wrappedResponse;\n      },\n    );\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async *findBlobsByTagsSegments(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {},\n  ): AsyncIterableIterator<ServiceFindBlobsByTagsSegmentResponse> {\n    let response;\n    if (!!marker || marker === undefined) {\n      do {\n        response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);\n        response.blobs = response.blobs || [];\n        marker = response.continuationToken;\n        yield response;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n  private async *findBlobsByTagsItems(\n    tagFilterSqlExpression: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {},\n  ): AsyncIterableIterator<FilterBlobItem> {\n    let marker: string | undefined;\n    for await (const segment of this.findBlobsByTagsSegments(\n      tagFilterSqlExpression,\n      marker,\n      options,\n    )) {\n      yield* segment.blobs;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n  public findBlobsByTags(\n    tagFilterSqlExpression: string,\n    options: ServiceFindBlobByTagsOptions = {},\n  ): PagedAsyncIterableIterator<FilterBlobItem, ServiceFindBlobsByTagsSegmentResponse> {\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions: ServiceFindBlobsByTagsSegmentOptions = {\n      ...options,\n    };\n\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...listSegmentOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to list containers operation.\n   */\n  private async *listSegments(\n    marker?: string,\n    options: ServiceListContainersSegmentOptions = {},\n  ): AsyncIterableIterator<ServiceListContainersSegmentResponse> {\n    let listContainersSegmentResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listContainersSegmentResponse = await this.listContainersSegment(marker, options);\n        listContainersSegmentResponse.containerItems =\n          listContainersSegmentResponse.containerItems || [];\n        marker = listContainersSegmentResponse.continuationToken;\n        yield await listContainersSegmentResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for Container Items\n   *\n   * @param options - Options to list containers operation.\n   */\n  private async *listItems(\n    options: ServiceListContainersSegmentOptions = {},\n  ): AsyncIterableIterator<ContainerItem> {\n    let marker: string | undefined;\n    for await (const segment of this.listSegments(marker, options)) {\n      yield* segment.containerItems;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the containers\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the containers in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const container of blobServiceClient.listContainers()) {\n   *   console.log(`Container ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.listContainers();\n   * let containerItem = await iter.next();\n   * while (!containerItem.done) {\n   *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n   *   containerItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n   *   if (response.containerItems) {\n   *     for (const container of response.containerItems) {\n   *       console.log(`Container ${i++}: ${container.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *     console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .listContainers()\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *      console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param options - Options to list containers.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listContainers(\n    options: ServiceListContainersOptions = {},\n  ): PagedAsyncIterableIterator<ContainerItem, ServiceListContainersSegmentResponse> {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const include: ListContainersIncludeType[] = [];\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n    if (options.includeSystem) {\n      include.push(\"system\");\n    }\n\n    // AsyncIterableIterator to iterate over containers\n    const listSegmentOptions: ServiceListContainersSegmentOptions = {\n      ...options,\n      ...(include.length > 0 ? { include } : {}),\n    };\n\n    const iter = this.listItems(listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.listSegments(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...listSegmentOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n   *\n   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n   * bearer token authentication.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n   *\n   * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n   * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n   */\n  public async getUserDelegationKey(\n    startsOn: Date,\n    expiresOn: Date,\n    options: ServiceGetUserDelegationKeyOptions = {},\n  ): Promise<ServiceGetUserDelegationKeyResponse> {\n    return tracingClient.withSpan(\n      \"BlobServiceClient-getUserDelegationKey\",\n      options,\n      async (updatedOptions) => {\n        const response = assertResponse<\n          ServiceGetUserDelegationKeyResponseModel,\n          ServiceGetUserDelegationKeyHeaders,\n          UserDelegationKeyModel\n        >(\n          await this.serviceContext.getUserDelegationKey(\n            {\n              startsOn: truncatedISO8061Date(startsOn, false),\n              expiresOn: truncatedISO8061Date(expiresOn, false),\n            },\n            {\n              abortSignal: options.abortSignal,\n              tracingOptions: updatedOptions.tracingOptions,\n            },\n          ),\n        );\n\n        const userDelegationKey = {\n          signedObjectId: response.signedObjectId,\n          signedTenantId: response.signedTenantId,\n          signedStartsOn: new Date(response.signedStartsOn),\n          signedExpiresOn: new Date(response.signedExpiresOn),\n          signedService: response.signedService,\n          signedVersion: response.signedVersion,\n          value: response.value,\n        };\n\n        const res: ServiceGetUserDelegationKeyResponse = {\n          _response: response._response,\n          requestId: response.requestId,\n          clientRequestId: response.clientRequestId,\n          version: response.version,\n          date: response.date,\n          errorCode: response.errorCode,\n          ...userDelegationKey,\n        };\n\n        return res;\n      },\n    );\n  }\n\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this service.\n   */\n  public getBlobBatchClient(): BlobBatchClient {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateAccountSasUrl(\n    expiresOn?: Date,\n    permissions: AccountSASPermissions = AccountSASPermissions.parse(\"r\"),\n    resourceTypes: string = \"sco\",\n    options: ServiceGenerateAccountSasUrlOptions = {},\n  ): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the account SAS when the client is initialized with a shared key credential\",\n      );\n    }\n\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n\n    const sas = generateAccountSASQueryParameters(\n      {\n        permissions,\n        expiresOn,\n        resourceTypes,\n        services: AccountSASServices.parse(\"b\").toString(),\n        ...options,\n      },\n      this.credential,\n    ).toString();\n\n    return appendToURLQuery(this.url, sas);\n  }\n\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates string to sign for a Blob account Shared Access Signature (SAS) URI based on\n   * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasStringToSign(\n    expiresOn?: Date,\n    permissions: AccountSASPermissions = AccountSASPermissions.parse(\"r\"),\n    resourceTypes: string = \"sco\",\n    options: ServiceGenerateAccountSasUrlOptions = {},\n  ): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the account SAS when the client is initialized with a shared key credential\",\n      );\n    }\n\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n\n    return generateAccountSASQueryParametersInternal(\n      {\n        permissions,\n        expiresOn,\n        resourceTypes,\n        services: AccountSASServices.parse(\"b\").toString(),\n        ...options,\n      },\n      this.credential,\n    ).stringToSign;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}