{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { initOperation, pollOperation } from \"../poller/operation.js\";\nimport { logger } from \"../logger.js\";\nfunction getOperationLocationPollingUrl(inputs) {\n  const {\n    azureAsyncOperation,\n    operationLocation\n  } = inputs;\n  return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;\n}\nfunction getLocationHeader(rawResponse) {\n  return rawResponse.headers[\"location\"];\n}\nfunction getOperationLocationHeader(rawResponse) {\n  return rawResponse.headers[\"operation-location\"];\n}\nfunction getAzureAsyncOperationHeader(rawResponse) {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\nfunction findResourceLocation(inputs) {\n  var _a;\n  const {\n    location,\n    requestMethod,\n    requestPath,\n    resourceLocationConfig\n  } = inputs;\n  switch (requestMethod) {\n    case \"PUT\":\n      {\n        return requestPath;\n      }\n    case \"DELETE\":\n      {\n        return undefined;\n      }\n    case \"PATCH\":\n      {\n        return (_a = getDefault()) !== null && _a !== void 0 ? _a : requestPath;\n      }\n    default:\n      {\n        return getDefault();\n      }\n  }\n  function getDefault() {\n    switch (resourceLocationConfig) {\n      case \"azure-async-operation\":\n        {\n          return undefined;\n        }\n      case \"original-uri\":\n        {\n          return requestPath;\n        }\n      case \"location\":\n      default:\n        {\n          return location;\n        }\n    }\n  }\n}\nexport function inferLroMode(inputs) {\n  const {\n    rawResponse,\n    requestMethod,\n    requestPath,\n    resourceLocationConfig\n  } = inputs;\n  const operationLocation = getOperationLocationHeader(rawResponse);\n  const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);\n  const pollingUrl = getOperationLocationPollingUrl({\n    operationLocation,\n    azureAsyncOperation\n  });\n  const location = getLocationHeader(rawResponse);\n  const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();\n  if (pollingUrl !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      operationLocation: pollingUrl,\n      resourceLocation: findResourceLocation({\n        requestMethod: normalizedRequestMethod,\n        location,\n        requestPath,\n        resourceLocationConfig\n      })\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      operationLocation: location\n    };\n  } else if (normalizedRequestMethod === \"PUT\" && requestPath) {\n    return {\n      mode: \"Body\",\n      operationLocation: requestPath\n    };\n  } else {\n    return undefined;\n  }\n}\nfunction transformStatus(inputs) {\n  const {\n    status,\n    statusCode\n  } = inputs;\n  if (typeof status !== \"string\" && status !== undefined) {\n    throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);\n  }\n  switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {\n    case undefined:\n      return toOperationStatus(statusCode);\n    case \"succeeded\":\n      return \"succeeded\";\n    case \"failed\":\n      return \"failed\";\n    case \"running\":\n    case \"accepted\":\n    case \"started\":\n    case \"canceling\":\n    case \"cancelling\":\n      return \"running\";\n    case \"canceled\":\n    case \"cancelled\":\n      return \"canceled\";\n    default:\n      {\n        logger.verbose(`LRO: unrecognized operation status: ${status}`);\n        return status;\n      }\n  }\n}\nfunction getStatus(rawResponse) {\n  var _a;\n  const {\n    status\n  } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};\n  return transformStatus({\n    status,\n    statusCode: rawResponse.statusCode\n  });\n}\nfunction getProvisioningState(rawResponse) {\n  var _a, _b;\n  const {\n    properties,\n    provisioningState\n  } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};\n  const status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;\n  return transformStatus({\n    status,\n    statusCode: rawResponse.statusCode\n  });\n}\nfunction toOperationStatus(statusCode) {\n  if (statusCode === 202) {\n    return \"running\";\n  } else if (statusCode < 300) {\n    return \"succeeded\";\n  } else {\n    return \"failed\";\n  }\n}\nexport function parseRetryAfter(_ref) {\n  let {\n    rawResponse\n  } = _ref;\n  const retryAfter = rawResponse.headers[\"retry-after\"];\n  if (retryAfter !== undefined) {\n    // Retry-After header value is either in HTTP date format, or in seconds\n    const retryAfterInSeconds = parseInt(retryAfter);\n    return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;\n  }\n  return undefined;\n}\nexport function getErrorFromResponse(response) {\n  const error = accessBodyProperty(response, \"error\");\n  if (!error) {\n    logger.warning(`The long-running operation failed but there is no error property in the response's body`);\n    return;\n  }\n  if (!error.code || !error.message) {\n    logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);\n    return;\n  }\n  return error;\n}\nfunction calculatePollingIntervalFromDate(retryAfterDate) {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n  return undefined;\n}\nexport function getStatusFromInitialResponse(inputs) {\n  const {\n    response,\n    state,\n    operationLocation\n  } = inputs;\n  function helper() {\n    var _a;\n    const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n    switch (mode) {\n      case undefined:\n        return toOperationStatus(response.rawResponse.statusCode);\n      case \"Body\":\n        return getOperationStatus(response, state);\n      default:\n        return \"running\";\n    }\n  }\n  const status = helper();\n  return status === \"running\" && operationLocation === undefined ? \"succeeded\" : status;\n}\n/**\n * Initiates the long-running operation.\n */\nexport async function initHttpOperation(inputs) {\n  const {\n    stateProxy,\n    resourceLocationConfig,\n    processResult,\n    lro,\n    setErrorAsResult\n  } = inputs;\n  return initOperation({\n    init: async () => {\n      const response = await lro.sendInitialRequest();\n      const config = inferLroMode({\n        rawResponse: response.rawResponse,\n        requestPath: lro.requestPath,\n        requestMethod: lro.requestMethod,\n        resourceLocationConfig\n      });\n      return Object.assign({\n        response,\n        operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,\n        resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation\n      }, (config === null || config === void 0 ? void 0 : config.mode) ? {\n        metadata: {\n          mode: config.mode\n        }\n      } : {});\n    },\n    stateProxy,\n    processResult: processResult ? (_ref2, state) => {\n      let {\n        flatResponse\n      } = _ref2;\n      return processResult(flatResponse, state);\n    } : _ref3 => {\n      let {\n        flatResponse\n      } = _ref3;\n      return flatResponse;\n    },\n    getOperationStatus: getStatusFromInitialResponse,\n    setErrorAsResult\n  });\n}\nexport function getOperationLocation(_ref4, state) {\n  let {\n    rawResponse\n  } = _ref4;\n  var _a;\n  const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getOperationLocationPollingUrl({\n          operationLocation: getOperationLocationHeader(rawResponse),\n          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)\n        });\n      }\n    case \"ResourceLocation\":\n      {\n        return getLocationHeader(rawResponse);\n      }\n    case \"Body\":\n    default:\n      {\n        return undefined;\n      }\n  }\n}\nexport function getOperationStatus(_ref5, state) {\n  let {\n    rawResponse\n  } = _ref5;\n  var _a;\n  const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getStatus(rawResponse);\n      }\n    case \"ResourceLocation\":\n      {\n        return toOperationStatus(rawResponse.statusCode);\n      }\n    case \"Body\":\n      {\n        return getProvisioningState(rawResponse);\n      }\n    default:\n      throw new Error(`Internal error: Unexpected operation mode: ${mode}`);\n  }\n}\nfunction accessBodyProperty(_ref6, prop) {\n  let {\n    flatResponse,\n    rawResponse\n  } = _ref6;\n  var _a, _b;\n  return (_a = flatResponse === null || flatResponse === void 0 ? void 0 : flatResponse[prop]) !== null && _a !== void 0 ? _a : (_b = rawResponse.body) === null || _b === void 0 ? void 0 : _b[prop];\n}\nexport function getResourceLocation(res, state) {\n  const loc = accessBodyProperty(res, \"resourceLocation\");\n  if (loc && typeof loc === \"string\") {\n    state.config.resourceLocation = loc;\n  }\n  return state.config.resourceLocation;\n}\nexport function isOperationError(e) {\n  return e.name === \"RestError\";\n}\n/** Polls the long-running operation. */\nexport async function pollHttpOperation(inputs) {\n  const {\n    lro,\n    stateProxy,\n    options,\n    processResult,\n    updateState,\n    setDelay,\n    state,\n    setErrorAsResult\n  } = inputs;\n  return pollOperation({\n    state,\n    stateProxy,\n    setDelay,\n    processResult: processResult ? (_ref7, inputState) => {\n      let {\n        flatResponse\n      } = _ref7;\n      return processResult(flatResponse, inputState);\n    } : _ref8 => {\n      let {\n        flatResponse\n      } = _ref8;\n      return flatResponse;\n    },\n    getError: getErrorFromResponse,\n    updateState,\n    getPollingInterval: parseRetryAfter,\n    getOperationLocation,\n    getOperationStatus,\n    isOperationError,\n    getResourceLocation,\n    options,\n    /**\n     * The expansion here is intentional because `lro` could be an object that\n     * references an inner this, so we need to preserve a reference to it.\n     */\n    poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),\n    setErrorAsResult\n  });\n}","map":{"version":3,"names":["initOperation","pollOperation","logger","getOperationLocationPollingUrl","inputs","azureAsyncOperation","operationLocation","getLocationHeader","rawResponse","headers","getOperationLocationHeader","getAzureAsyncOperationHeader","findResourceLocation","location","requestMethod","requestPath","resourceLocationConfig","undefined","_a","getDefault","inferLroMode","pollingUrl","normalizedRequestMethod","toLocaleUpperCase","mode","resourceLocation","transformStatus","status","statusCode","Error","toLocaleLowerCase","toOperationStatus","verbose","getStatus","body","getProvisioningState","properties","provisioningState","_b","parseRetryAfter","_ref","retryAfter","retryAfterInSeconds","parseInt","isNaN","calculatePollingIntervalFromDate","Date","getErrorFromResponse","response","error","accessBodyProperty","warning","code","message","retryAfterDate","timeNow","Math","floor","getTime","retryAfterTime","getStatusFromInitialResponse","state","helper","config","metadata","getOperationStatus","initHttpOperation","stateProxy","processResult","lro","setErrorAsResult","init","sendInitialRequest","Object","assign","_ref2","flatResponse","_ref3","getOperationLocation","_ref4","_ref5","_ref6","prop","getResourceLocation","res","loc","isOperationError","e","name","pollHttpOperation","options","updateState","setDelay","_ref7","inputState","_ref8","getError","getPollingInterval","poll","inputOptions","sendPollRequest"],"sources":["C:\\Users\\rdpro\\Projects\\NW Michigan Watershed Coalition\\client\\node_modules\\@azure\\core-lro\\src\\http\\operation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  HttpOperationMode,\n  LongRunningOperation,\n  LroResourceLocationConfig,\n  LroResponse,\n  RawResponse,\n  ResponseBody,\n} from \"./models.js\";\nimport {\n  LroError,\n  OperationConfig,\n  OperationStatus,\n  RestorableOperationState,\n  StateProxy,\n} from \"../poller/models.js\";\nimport { initOperation, pollOperation } from \"../poller/operation.js\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { logger } from \"../logger.js\";\n\nfunction getOperationLocationPollingUrl(inputs: {\n  operationLocation?: string;\n  azureAsyncOperation?: string;\n}): string | undefined {\n  const { azureAsyncOperation, operationLocation } = inputs;\n  return operationLocation ?? azureAsyncOperation;\n}\n\nfunction getLocationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"location\"];\n}\n\nfunction getOperationLocationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"operation-location\"];\n}\n\nfunction getAzureAsyncOperationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\n\nfunction findResourceLocation(inputs: {\n  requestMethod?: string;\n  location?: string;\n  requestPath?: string;\n  resourceLocationConfig?: LroResourceLocationConfig;\n}): string | undefined {\n  const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;\n  switch (requestMethod) {\n    case \"PUT\": {\n      return requestPath;\n    }\n    case \"DELETE\": {\n      return undefined;\n    }\n    case \"PATCH\": {\n      return getDefault() ?? requestPath;\n    }\n    default: {\n      return getDefault();\n    }\n  }\n\n  function getDefault() {\n    switch (resourceLocationConfig) {\n      case \"azure-async-operation\": {\n        return undefined;\n      }\n      case \"original-uri\": {\n        return requestPath;\n      }\n      case \"location\":\n      default: {\n        return location;\n      }\n    }\n  }\n}\n\nexport function inferLroMode(inputs: {\n  rawResponse: RawResponse;\n  requestPath?: string;\n  requestMethod?: string;\n  resourceLocationConfig?: LroResourceLocationConfig;\n}): (OperationConfig & { mode: HttpOperationMode }) | undefined {\n  const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;\n  const operationLocation = getOperationLocationHeader(rawResponse);\n  const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);\n  const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });\n  const location = getLocationHeader(rawResponse);\n  const normalizedRequestMethod = requestMethod?.toLocaleUpperCase();\n  if (pollingUrl !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      operationLocation: pollingUrl,\n      resourceLocation: findResourceLocation({\n        requestMethod: normalizedRequestMethod,\n        location,\n        requestPath,\n        resourceLocationConfig,\n      }),\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      operationLocation: location,\n    };\n  } else if (normalizedRequestMethod === \"PUT\" && requestPath) {\n    return {\n      mode: \"Body\",\n      operationLocation: requestPath,\n    };\n  } else {\n    return undefined;\n  }\n}\n\nfunction transformStatus(inputs: { status: unknown; statusCode: number }): OperationStatus {\n  const { status, statusCode } = inputs;\n  if (typeof status !== \"string\" && status !== undefined) {\n    throw new Error(\n      `Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`,\n    );\n  }\n  switch (status?.toLocaleLowerCase()) {\n    case undefined:\n      return toOperationStatus(statusCode);\n    case \"succeeded\":\n      return \"succeeded\";\n    case \"failed\":\n      return \"failed\";\n    case \"running\":\n    case \"accepted\":\n    case \"started\":\n    case \"canceling\":\n    case \"cancelling\":\n      return \"running\";\n    case \"canceled\":\n    case \"cancelled\":\n      return \"canceled\";\n    default: {\n      logger.verbose(`LRO: unrecognized operation status: ${status}`);\n      return status as OperationStatus;\n    }\n  }\n}\n\nfunction getStatus(rawResponse: RawResponse): OperationStatus {\n  const { status } = (rawResponse.body as ResponseBody) ?? {};\n  return transformStatus({ status, statusCode: rawResponse.statusCode });\n}\n\nfunction getProvisioningState(rawResponse: RawResponse): OperationStatus {\n  const { properties, provisioningState } = (rawResponse.body as ResponseBody) ?? {};\n  const status = properties?.provisioningState ?? provisioningState;\n  return transformStatus({ status, statusCode: rawResponse.statusCode });\n}\n\nfunction toOperationStatus(statusCode: number): OperationStatus {\n  if (statusCode === 202) {\n    return \"running\";\n  } else if (statusCode < 300) {\n    return \"succeeded\";\n  } else {\n    return \"failed\";\n  }\n}\n\nexport function parseRetryAfter<T>({ rawResponse }: LroResponse<T>): number | undefined {\n  const retryAfter: string | undefined = rawResponse.headers[\"retry-after\"];\n  if (retryAfter !== undefined) {\n    // Retry-After header value is either in HTTP date format, or in seconds\n    const retryAfterInSeconds = parseInt(retryAfter);\n    return isNaN(retryAfterInSeconds)\n      ? calculatePollingIntervalFromDate(new Date(retryAfter))\n      : retryAfterInSeconds * 1000;\n  }\n  return undefined;\n}\n\nexport function getErrorFromResponse<T>(response: LroResponse<T>): LroError | undefined {\n  const error = accessBodyProperty(response, \"error\");\n  if (!error) {\n    logger.warning(\n      `The long-running operation failed but there is no error property in the response's body`,\n    );\n    return;\n  }\n  if (!error.code || !error.message) {\n    logger.warning(\n      `The long-running operation failed but the error property in the response's body doesn't contain code or message`,\n    );\n    return;\n  }\n  return error as LroError;\n}\n\nfunction calculatePollingIntervalFromDate(retryAfterDate: Date): number | undefined {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n  return undefined;\n}\n\nexport function getStatusFromInitialResponse<TState>(inputs: {\n  response: LroResponse<unknown>;\n  state: RestorableOperationState<TState>;\n  operationLocation?: string;\n}): OperationStatus {\n  const { response, state, operationLocation } = inputs;\n  function helper(): OperationStatus {\n    const mode = state.config.metadata?.[\"mode\"];\n    switch (mode) {\n      case undefined:\n        return toOperationStatus(response.rawResponse.statusCode);\n      case \"Body\":\n        return getOperationStatus(response, state);\n      default:\n        return \"running\";\n    }\n  }\n  const status = helper();\n  return status === \"running\" && operationLocation === undefined ? \"succeeded\" : status;\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initHttpOperation<TResult, TState>(inputs: {\n  stateProxy: StateProxy<TState, TResult>;\n  resourceLocationConfig?: LroResourceLocationConfig;\n  processResult?: (result: unknown, state: TState) => TResult;\n  setErrorAsResult: boolean;\n  lro: LongRunningOperation;\n}): Promise<RestorableOperationState<TState>> {\n  const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;\n  return initOperation({\n    init: async () => {\n      const response = await lro.sendInitialRequest();\n      const config = inferLroMode({\n        rawResponse: response.rawResponse,\n        requestPath: lro.requestPath,\n        requestMethod: lro.requestMethod,\n        resourceLocationConfig,\n      });\n      return {\n        response,\n        operationLocation: config?.operationLocation,\n        resourceLocation: config?.resourceLocation,\n        ...(config?.mode ? { metadata: { mode: config.mode } } : {}),\n      };\n    },\n    stateProxy,\n    processResult: processResult\n      ? ({ flatResponse }, state) => processResult(flatResponse, state)\n      : ({ flatResponse }) => flatResponse as TResult,\n    getOperationStatus: getStatusFromInitialResponse,\n    setErrorAsResult,\n  });\n}\n\nexport function getOperationLocation<TState>(\n  { rawResponse }: LroResponse,\n  state: RestorableOperationState<TState>,\n): string | undefined {\n  const mode = state.config.metadata?.[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\": {\n      return getOperationLocationPollingUrl({\n        operationLocation: getOperationLocationHeader(rawResponse),\n        azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse),\n      });\n    }\n    case \"ResourceLocation\": {\n      return getLocationHeader(rawResponse);\n    }\n    case \"Body\":\n    default: {\n      return undefined;\n    }\n  }\n}\n\nexport function getOperationStatus<TState>(\n  { rawResponse }: LroResponse,\n  state: RestorableOperationState<TState>,\n): OperationStatus {\n  const mode = state.config.metadata?.[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\": {\n      return getStatus(rawResponse);\n    }\n    case \"ResourceLocation\": {\n      return toOperationStatus(rawResponse.statusCode);\n    }\n    case \"Body\": {\n      return getProvisioningState(rawResponse);\n    }\n    default:\n      throw new Error(`Internal error: Unexpected operation mode: ${mode}`);\n  }\n}\n\nfunction accessBodyProperty<P extends string>(\n  { flatResponse, rawResponse }: LroResponse,\n  prop: P,\n): ResponseBody[P] {\n  return (flatResponse as ResponseBody)?.[prop] ?? (rawResponse.body as ResponseBody)?.[prop];\n}\n\nexport function getResourceLocation<TState>(\n  res: LroResponse,\n  state: RestorableOperationState<TState>,\n): string | undefined {\n  const loc = accessBodyProperty(res, \"resourceLocation\");\n  if (loc && typeof loc === \"string\") {\n    state.config.resourceLocation = loc;\n  }\n  return state.config.resourceLocation;\n}\n\nexport function isOperationError(e: Error): boolean {\n  return e.name === \"RestError\";\n}\n\n/** Polls the long-running operation. */\nexport async function pollHttpOperation<TState, TResult>(inputs: {\n  lro: LongRunningOperation;\n  stateProxy: StateProxy<TState, TResult>;\n  processResult?: (result: unknown, state: TState) => TResult;\n  updateState?: (state: TState, lastResponse: LroResponse) => void;\n  isDone?: (lastResponse: LroResponse, state: TState) => boolean;\n  setDelay: (intervalInMs: number) => void;\n  options?: { abortSignal?: AbortSignalLike };\n  state: RestorableOperationState<TState>;\n  setErrorAsResult: boolean;\n}): Promise<void> {\n  const {\n    lro,\n    stateProxy,\n    options,\n    processResult,\n    updateState,\n    setDelay,\n    state,\n    setErrorAsResult,\n  } = inputs;\n  return pollOperation({\n    state,\n    stateProxy,\n    setDelay,\n    processResult: processResult\n      ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState)\n      : ({ flatResponse }) => flatResponse as TResult,\n    getError: getErrorFromResponse,\n    updateState,\n    getPollingInterval: parseRetryAfter,\n    getOperationLocation,\n    getOperationStatus,\n    isOperationError,\n    getResourceLocation,\n    options,\n    /**\n     * The expansion here is intentional because `lro` could be an object that\n     * references an inner this, so we need to preserve a reference to it.\n     */\n    poll: async (location: string, inputOptions?: { abortSignal?: AbortSignalLike }) =>\n      lro.sendPollRequest(location, inputOptions),\n    setErrorAsResult,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}