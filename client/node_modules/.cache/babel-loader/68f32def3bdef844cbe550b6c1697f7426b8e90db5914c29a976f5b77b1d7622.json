{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { isRestError, RestError } from \"@azure/core-rest-pipeline\";\nimport { getErrorMessage } from \"@azure/core-util\";\nimport { URLConstants } from \"../utils/constants\";\nimport { delay, setURLHost, setURLParameter } from \"../utils/utils.common\";\nimport { logger } from \"../log\";\n/**\n * Name of the {@link storageRetryPolicy}\n */\nexport const storageRetryPolicyName = \"storageRetryPolicy\";\n/**\n * RetryPolicy types.\n */\nexport var StorageRetryPolicyType;\n(function (StorageRetryPolicyType) {\n  /**\n   * Exponential retry. Retry time delay grows exponentially.\n   */\n  StorageRetryPolicyType[StorageRetryPolicyType[\"EXPONENTIAL\"] = 0] = \"EXPONENTIAL\";\n  /**\n   * Linear retry. Retry time delay grows linearly.\n   */\n  StorageRetryPolicyType[StorageRetryPolicyType[\"FIXED\"] = 1] = \"FIXED\";\n})(StorageRetryPolicyType || (StorageRetryPolicyType = {}));\n// Default values of StorageRetryOptions\nconst DEFAULT_RETRY_OPTIONS = {\n  maxRetryDelayInMs: 120 * 1000,\n  maxTries: 4,\n  retryDelayInMs: 4 * 1000,\n  retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,\n  secondaryHost: \"\",\n  tryTimeoutInMs: undefined // Use server side default timeout strategy\n};\nconst retriableErrors = [\"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\", \"ENOENT\", \"ENOTFOUND\", \"TIMEOUT\", \"EPIPE\", \"REQUEST_SEND_ERROR\"];\nconst RETRY_ABORT_ERROR = new AbortError(\"The operation was aborted.\");\n/**\n * Retry policy with exponential retry and linear retry implemented.\n */\nexport function storageRetryPolicy(options = {}) {\n  var _a, _b, _c, _d, _e, _f;\n  const retryPolicyType = (_a = options.retryPolicyType) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_OPTIONS.retryPolicyType;\n  const maxTries = (_b = options.maxTries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_OPTIONS.maxTries;\n  const retryDelayInMs = (_c = options.retryDelayInMs) !== null && _c !== void 0 ? _c : DEFAULT_RETRY_OPTIONS.retryDelayInMs;\n  const maxRetryDelayInMs = (_d = options.maxRetryDelayInMs) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;\n  const secondaryHost = (_e = options.secondaryHost) !== null && _e !== void 0 ? _e : DEFAULT_RETRY_OPTIONS.secondaryHost;\n  const tryTimeoutInMs = (_f = options.tryTimeoutInMs) !== null && _f !== void 0 ? _f : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;\n  function shouldRetry({\n    isPrimaryRetry,\n    attempt,\n    response,\n    error\n  }) {\n    var _a, _b;\n    if (attempt >= maxTries) {\n      logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);\n      return false;\n    }\n    if (error) {\n      for (const retriableError of retriableErrors) {\n        if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {\n          logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);\n          return true;\n        }\n      }\n      if ((error === null || error === void 0 ? void 0 : error.code) === \"PARSE_ERROR\" && (error === null || error === void 0 ? void 0 : error.message.startsWith(`Error \"Error: Unclosed root tag`))) {\n        logger.info(\"RetryPolicy: Incomplete XML response likely due to service timeout, will retry.\");\n        return true;\n      }\n    }\n    // If attempt was against the secondary & it returned a StatusNotFound (404), then\n    // the resource was not found. This may be due to replication delay. So, in this\n    // case, we'll never try the secondary again for this operation.\n    if (response || error) {\n      const statusCode = (_b = (_a = response === null || response === void 0 ? void 0 : response.status) !== null && _a !== void 0 ? _a : error === null || error === void 0 ? void 0 : error.statusCode) !== null && _b !== void 0 ? _b : 0;\n      if (!isPrimaryRetry && statusCode === 404) {\n        logger.info(`RetryPolicy: Secondary access with 404, will retry.`);\n        return true;\n      }\n      // Server internal error or server timeout\n      if (statusCode === 503 || statusCode === 500) {\n        logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);\n        return true;\n      }\n    }\n    // [Copy source error code] Feature is pending on service side, skip retry on copy source error for now.\n    // if (response) {\n    //   // Retry select Copy Source Error Codes.\n    //   if (response?.status >= 400) {\n    //     const copySourceError = response.headers.get(HeaderConstants.X_MS_CopySourceErrorCode);\n    //     if (copySourceError !== undefined) {\n    //       switch (copySourceError) {\n    //         case \"InternalError\":\n    //         case \"OperationTimedOut\":\n    //         case \"ServerBusy\":\n    //           return true;\n    //       }\n    //     }\n    //   }\n    // }\n    return false;\n  }\n  function calculateDelay(isPrimaryRetry, attempt) {\n    let delayTimeInMs = 0;\n    if (isPrimaryRetry) {\n      switch (retryPolicyType) {\n        case StorageRetryPolicyType.EXPONENTIAL:\n          delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);\n          break;\n        case StorageRetryPolicyType.FIXED:\n          delayTimeInMs = retryDelayInMs;\n          break;\n      }\n    } else {\n      delayTimeInMs = Math.random() * 1000;\n    }\n    logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);\n    return delayTimeInMs;\n  }\n  return {\n    name: storageRetryPolicyName,\n    async sendRequest(request, next) {\n      // Set the server-side timeout query parameter \"timeout=[seconds]\"\n      if (tryTimeoutInMs) {\n        request.url = setURLParameter(request.url, URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));\n      }\n      const primaryUrl = request.url;\n      const secondaryUrl = secondaryHost ? setURLHost(request.url, secondaryHost) : undefined;\n      let secondaryHas404 = false;\n      let attempt = 1;\n      let retryAgain = true;\n      let response;\n      let error;\n      while (retryAgain) {\n        const isPrimaryRetry = secondaryHas404 || !secondaryUrl || ![\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method) || attempt % 2 === 1;\n        request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;\n        response = undefined;\n        error = undefined;\n        try {\n          logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? \"Primary\" : \"Secondary\"}`);\n          response = await next(request);\n          secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;\n        } catch (e) {\n          if (isRestError(e)) {\n            logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);\n            error = e;\n          } else {\n            logger.error(`RetryPolicy: Caught error, message: ${getErrorMessage(e)}`);\n            throw e;\n          }\n        }\n        retryAgain = shouldRetry({\n          isPrimaryRetry,\n          attempt,\n          response,\n          error\n        });\n        if (retryAgain) {\n          await delay(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);\n        }\n        attempt++;\n      }\n      if (response) {\n        return response;\n      }\n      throw error !== null && error !== void 0 ? error : new RestError(\"RetryPolicy failed without known error.\");\n    }\n  };\n}","map":{"version":3,"names":["AbortError","isRestError","RestError","getErrorMessage","URLConstants","delay","setURLHost","setURLParameter","logger","storageRetryPolicyName","StorageRetryPolicyType","DEFAULT_RETRY_OPTIONS","maxRetryDelayInMs","maxTries","retryDelayInMs","retryPolicyType","EXPONENTIAL","secondaryHost","tryTimeoutInMs","undefined","retriableErrors","RETRY_ABORT_ERROR","storageRetryPolicy","options","_a","_b","_c","_d","_e","_f","shouldRetry","isPrimaryRetry","attempt","response","error","info","retriableError","name","toUpperCase","includes","message","code","toString","startsWith","statusCode","status","calculateDelay","delayTimeInMs","Math","min","pow","FIXED","random","sendRequest","request","next","url","Parameters","TIMEOUT","String","floor","primaryUrl","secondaryUrl","secondaryHas404","retryAgain","method","e","abortSignal"],"sources":["C:\\Users\\rdpro\\Projects\\NW Michigan Watershed Coalition\\client\\node_modules\\@azure\\storage-blob\\src\\policies\\StorageRetryPolicyV2.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport type {\n  PipelinePolicy,\n  PipelineRequest,\n  SendRequest,\n  PipelineResponse,\n} from \"@azure/core-rest-pipeline\";\nimport { isRestError, RestError } from \"@azure/core-rest-pipeline\";\nimport { getErrorMessage } from \"@azure/core-util\";\nimport type { StorageRetryOptions } from \"../StorageRetryPolicyFactory\";\nimport { URLConstants } from \"../utils/constants\";\nimport { delay, setURLHost, setURLParameter } from \"../utils/utils.common\";\nimport { logger } from \"../log\";\n\n/**\n * Name of the {@link storageRetryPolicy}\n */\nexport const storageRetryPolicyName = \"storageRetryPolicy\";\n\n/**\n * RetryPolicy types.\n */\nexport enum StorageRetryPolicyType {\n  /**\n   * Exponential retry. Retry time delay grows exponentially.\n   */\n  EXPONENTIAL,\n  /**\n   * Linear retry. Retry time delay grows linearly.\n   */\n  FIXED,\n}\n\n// Default values of StorageRetryOptions\nconst DEFAULT_RETRY_OPTIONS = {\n  maxRetryDelayInMs: 120 * 1000,\n  maxTries: 4,\n  retryDelayInMs: 4 * 1000,\n  retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,\n  secondaryHost: \"\",\n  tryTimeoutInMs: undefined, // Use server side default timeout strategy\n} as const;\n\nconst retriableErrors = [\n  \"ETIMEDOUT\",\n  \"ESOCKETTIMEDOUT\",\n  \"ECONNREFUSED\",\n  \"ECONNRESET\",\n  \"ENOENT\",\n  \"ENOTFOUND\",\n  \"TIMEOUT\",\n  \"EPIPE\",\n  \"REQUEST_SEND_ERROR\",\n] as const;\n\nconst RETRY_ABORT_ERROR = new AbortError(\"The operation was aborted.\");\n\n/**\n * Retry policy with exponential retry and linear retry implemented.\n */\nexport function storageRetryPolicy(options: StorageRetryOptions = {}): PipelinePolicy {\n  const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;\n  const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;\n  const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;\n  const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;\n  const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;\n  const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;\n\n  function shouldRetry({\n    isPrimaryRetry,\n    attempt,\n    response,\n    error,\n  }: {\n    isPrimaryRetry: boolean;\n    attempt: number;\n    response?: PipelineResponse;\n    error?: RestError;\n  }): boolean {\n    if (attempt >= maxTries) {\n      logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);\n      return false;\n    }\n    if (error) {\n      for (const retriableError of retriableErrors) {\n        if (\n          error.name.toUpperCase().includes(retriableError) ||\n          error.message.toUpperCase().includes(retriableError) ||\n          (error.code && error.code.toString().toUpperCase() === retriableError)\n        ) {\n          logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);\n          return true;\n        }\n      }\n      if (\n        error?.code === \"PARSE_ERROR\" &&\n        error?.message.startsWith(`Error \"Error: Unclosed root tag`)\n      ) {\n        logger.info(\n          \"RetryPolicy: Incomplete XML response likely due to service timeout, will retry.\",\n        );\n        return true;\n      }\n    }\n\n    // If attempt was against the secondary & it returned a StatusNotFound (404), then\n    // the resource was not found. This may be due to replication delay. So, in this\n    // case, we'll never try the secondary again for this operation.\n    if (response || error) {\n      const statusCode = response?.status ?? error?.statusCode ?? 0;\n      if (!isPrimaryRetry && statusCode === 404) {\n        logger.info(`RetryPolicy: Secondary access with 404, will retry.`);\n        return true;\n      }\n\n      // Server internal error or server timeout\n      if (statusCode === 503 || statusCode === 500) {\n        logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);\n        return true;\n      }\n    }\n\n    // [Copy source error code] Feature is pending on service side, skip retry on copy source error for now.\n    // if (response) {\n    //   // Retry select Copy Source Error Codes.\n    //   if (response?.status >= 400) {\n    //     const copySourceError = response.headers.get(HeaderConstants.X_MS_CopySourceErrorCode);\n    //     if (copySourceError !== undefined) {\n    //       switch (copySourceError) {\n    //         case \"InternalError\":\n    //         case \"OperationTimedOut\":\n    //         case \"ServerBusy\":\n    //           return true;\n    //       }\n    //     }\n    //   }\n    // }\n\n    return false;\n  }\n  function calculateDelay(isPrimaryRetry: boolean, attempt: number): number {\n    let delayTimeInMs = 0;\n\n    if (isPrimaryRetry) {\n      switch (retryPolicyType) {\n        case StorageRetryPolicyType.EXPONENTIAL:\n          delayTimeInMs = Math.min(\n            (Math.pow(2, attempt - 1) - 1) * retryDelayInMs,\n            maxRetryDelayInMs,\n          );\n          break;\n        case StorageRetryPolicyType.FIXED:\n          delayTimeInMs = retryDelayInMs;\n          break;\n      }\n    } else {\n      delayTimeInMs = Math.random() * 1000;\n    }\n\n    logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);\n    return delayTimeInMs;\n  }\n  return {\n    name: storageRetryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      // Set the server-side timeout query parameter \"timeout=[seconds]\"\n      if (tryTimeoutInMs) {\n        request.url = setURLParameter(\n          request.url,\n          URLConstants.Parameters.TIMEOUT,\n          String(Math.floor(tryTimeoutInMs / 1000)),\n        );\n      }\n      const primaryUrl = request.url;\n      const secondaryUrl = secondaryHost ? setURLHost(request.url, secondaryHost) : undefined;\n      let secondaryHas404 = false;\n      let attempt = 1;\n      let retryAgain = true;\n      let response: PipelineResponse | undefined;\n      let error: RestError | undefined;\n      while (retryAgain) {\n        const isPrimaryRetry: boolean =\n          secondaryHas404 ||\n          !secondaryUrl ||\n          ![\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method) ||\n          attempt % 2 === 1;\n        request.url = isPrimaryRetry ? primaryUrl : secondaryUrl!;\n        response = undefined;\n        error = undefined;\n        try {\n          logger.info(\n            `RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? \"Primary\" : \"Secondary\"}`,\n          );\n          response = await next(request);\n          secondaryHas404 = secondaryHas404 || (!isPrimaryRetry && response.status === 404);\n        } catch (e: unknown) {\n          if (isRestError(e)) {\n            logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);\n            error = e;\n          } else {\n            logger.error(`RetryPolicy: Caught error, message: ${getErrorMessage(e)}`);\n            throw e;\n          }\n        }\n        retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error });\n        if (retryAgain) {\n          await delay(\n            calculateDelay(isPrimaryRetry, attempt),\n            request.abortSignal,\n            RETRY_ABORT_ERROR,\n          );\n        }\n        attempt++;\n      }\n      if (response) {\n        return response;\n      }\n      throw error ?? new RestError(\"RetryPolicy failed without known error.\");\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}