{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./xml.common.js\";\nif (!document || !DOMParser || !Node || !XMLSerializer) {\n  throw new Error(`This library depends on the following DOM objects: [\"document\", \"DOMParser\", \"Node\", \"XMLSerializer\"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `);\n}\n// Policy to make our code Trusted Types compliant at running time.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\nlet ttPolicy;\ntry {\n  if (typeof self.trustedTypes !== \"undefined\") {\n    ttPolicy = self.trustedTypes.createPolicy(\"@azure/core-xml#xml.browser\", {\n      createHTML: s => s\n    });\n  }\n} catch (e) {\n  console.warn('Could not create trusted types policy \"@azure/core-xml#xml.browser\"');\n}\nconst doc = document.implementation.createDocument(null, null, null);\nconst parser = new DOMParser();\nexport function parseXML(str) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b, _c, _d, _e, _f;\n  try {\n    const updatedOptions = {\n      rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n      cdataPropName: (_d = opts.cdataPropName) !== null && _d !== void 0 ? _d : \"__cdata\",\n      stopNodes: (_e = opts.stopNodes) !== null && _e !== void 0 ? _e : []\n    };\n    const dom = parser.parseFromString((_f = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _f !== void 0 ? _f : str, \"application/xml\");\n    throwIfError(dom);\n    let obj;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nlet errorNS;\nfunction getErrorNamespace() {\n  var _a, _b;\n  if (errorNS === undefined) {\n    try {\n      const invalidXML = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(\"INVALID\")) !== null && _a !== void 0 ? _a : \"INVALID\";\n      errorNS = (_b = parser.parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0].namespaceURI) !== null && _b !== void 0 ? _b : \"\";\n    } catch (ignored) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n  return errorNS;\n}\nfunction throwIfError(dom) {\n  const parserErrors = dom.getElementsByTagName(\"parsererror\");\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (let i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\nfunction isElement(node) {\n  return !!node.attributes;\n}\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node) {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\nfunction domToObject(node, options) {\n  var _a;\n  let result = {};\n  const childNodeCount = node.childNodes.length;\n  const firstChildNode = node.childNodes[0];\n  const onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;\n  const elementWithAttributes = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Check if CData\n      if ((child === null || child === void 0 ? void 0 : child.nodeType) === Node.CDATA_SECTION_NODE) {\n        // Already in the CDATA\n        result = child.textContent;\n      } else if (((_a = child === null || child === void 0 ? void 0 : child.firstChild) === null || _a === void 0 ? void 0 : _a.nodeType) === Node.CDATA_SECTION_NODE) {\n        // Look if child is CDATA\n        result[child.nodeName] = child.textContent;\n      } else if (child.nodeType !== Node.TEXT_NODE) {\n        // Ignore leading/trailing whitespace nodes\n        const childObject = domToObject(child, options);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n  return result;\n}\nconst serializer = new XMLSerializer();\nexport function stringifyXML(content) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b, _c, _d, _e;\n  const updatedOptions = {\n    rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"root\",\n    includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n    xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n    cdataPropName: (_d = opts.cdataPropName) !== null && _d !== void 0 ? _d : \"__cdata\",\n    stopNodes: (_e = opts.stopNodes) !== null && _e !== void 0 ? _e : []\n  };\n  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom).replace(/ xmlns=\"\"/g, \"\");\n}\nfunction buildAttributes(attrs) {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\nfunction buildNode(obj, elementName, options) {\n  var _a;\n  if (obj === undefined || obj === null || typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName, options)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    let elem;\n    if ((_a = obj[XML_ATTRKEY]) === null || _a === void 0 ? void 0 : _a[\"xmlns\"]) {\n      elem = doc.createElementNS(obj[XML_ATTRKEY][\"xmlns\"], elementName);\n    } else {\n      elem = doc.createElement(elementName);\n    }\n    for (const key of Object.keys(obj)) {\n      if (key === XML_ATTRKEY) {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else if (key === options.cdataPropName) {\n        const cdataElement = doc.createCDATASection(obj[key].toString());\n        elem.appendChild(cdataElement);\n      } else {\n        for (const child of buildNode(obj[key], key, options)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}","map":{"version":3,"names":["XML_ATTRKEY","XML_CHARKEY","document","DOMParser","Node","XMLSerializer","Error","ttPolicy","self","trustedTypes","createPolicy","createHTML","s","e","console","warn","doc","implementation","createDocument","parser","parseXML","str","opts","arguments","length","undefined","updatedOptions","rootName","_a","includeRoot","_b","xmlCharKey","_c","cdataPropName","_d","stopNodes","_e","dom","parseFromString","_f","throwIfError","obj","domToObject","childNodes","Promise","resolve","err","reject","errorNS","getErrorNamespace","invalidXML","getElementsByTagName","namespaceURI","ignored","parserErrors","i","innerHTML","isElement","node","attributes","asElementWithAttributes","hasAttributes","options","result","childNodeCount","firstChildNode","onlyChildTextValue","nodeType","TEXT_NODE","nodeValue","elementWithAttributes","attr","nodeName","child","CDATA_SECTION_NODE","textContent","firstChild","childObject","Array","isArray","push","serializer","stringifyXML","content","buildNode","serializeToString","replace","buildAttributes","attrs","key","Object","keys","createAttribute","value","toString","elementName","elem","createElement","arrayElem","createElementNS","setNamedItem","cdataElement","createCDATASection","appendChild"],"sources":["C:\\Users\\rdpro\\Projects\\NW Michigan Watershed Coalition\\client\\node_modules\\@azure\\core-xml\\src\\xml-browser.mts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/// <reference lib=\"dom\"/>\nimport type { XmlOptions } from \"./xml.common.js\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./xml.common.js\";\n\nif (!document || !DOMParser || !Node || !XMLSerializer) {\n  throw new Error(\n    `This library depends on the following DOM objects: [\"document\", \"DOMParser\", \"Node\", \"XMLSerializer\"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `,\n  );\n}\n\n// Policy to make our code Trusted Types compliant at running time.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\nlet ttPolicy: Pick<TrustedTypePolicy, \"createHTML\"> | undefined;\ntry {\n  if (typeof self.trustedTypes !== \"undefined\") {\n    ttPolicy = self.trustedTypes.createPolicy(\"@azure/core-xml#xml.browser\", {\n      createHTML: (s: string) => s,\n    });\n  }\n} catch (e: any) {\n  console.warn('Could not create trusted types policy \"@azure/core-xml#xml.browser\"');\n}\n\nconst doc = document.implementation.createDocument(null, null, null);\n\nconst parser = new DOMParser();\nexport function parseXML(str: string, opts: XmlOptions = {}): Promise<any> {\n  try {\n    const updatedOptions: Required<XmlOptions> = {\n      rootName: opts.rootName ?? \"\",\n      includeRoot: opts.includeRoot ?? false,\n      xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY,\n      cdataPropName: opts.cdataPropName ?? \"__cdata\",\n      stopNodes: opts.stopNodes ?? [],\n    };\n    const dom = parser.parseFromString(\n      (ttPolicy?.createHTML(str) ?? str) as string,\n      \"application/xml\",\n    );\n    throwIfError(dom);\n\n    let obj;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err: any) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS: string | undefined;\n\nfunction getErrorNamespace(): string {\n  if (errorNS === undefined) {\n    try {\n      const invalidXML = (ttPolicy?.createHTML(\"INVALID\") ?? \"INVALID\") as string;\n      errorNS =\n        parser.parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n          .namespaceURI! ?? \"\";\n    } catch (ignored: any) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n\n  return errorNS;\n}\n\nfunction throwIfError(dom: Document): void {\n  const parserErrors = dom.getElementsByTagName(\"parsererror\");\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (let i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node, options: Required<XmlOptions>): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n\n      // Check if CData\n      if (child?.nodeType === Node.CDATA_SECTION_NODE) {\n        // Already in the CDATA\n        result = child.textContent;\n      } else if (child?.firstChild?.nodeType === Node.CDATA_SECTION_NODE) {\n        // Look if child is CDATA\n        result[child.nodeName] = child.textContent;\n      } else if (child.nodeType !== Node.TEXT_NODE) {\n        // Ignore leading/trailing whitespace nodes\n        const childObject: any = domToObject(child, options);\n\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nconst serializer = new XMLSerializer();\n\nexport function stringifyXML(content: unknown, opts: XmlOptions = {}): string {\n  const updatedOptions: Required<XmlOptions> = {\n    rootName: opts.rootName ?? \"root\",\n    includeRoot: opts.includeRoot ?? false,\n    xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY,\n    cdataPropName: opts.cdataPropName ?? \"__cdata\",\n    stopNodes: opts.stopNodes ?? [],\n  };\n  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n    serializer.serializeToString(dom).replace(/ xmlns=\"\"/g, \"\")\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string, options: Required<XmlOptions>): Node[] {\n  if (\n    obj === undefined ||\n    obj === null ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName, options)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    let elem: HTMLElement;\n    if (obj[XML_ATTRKEY]?.[\"xmlns\"]) {\n      elem = doc.createElementNS(obj[XML_ATTRKEY][\"xmlns\"], elementName);\n    } else {\n      elem = doc.createElement(elementName);\n    }\n    for (const key of Object.keys(obj)) {\n      if (key === XML_ATTRKEY) {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else if (key === options.cdataPropName) {\n        const cdataElement = doc.createCDATASection(obj[key].toString());\n        elem.appendChild(cdataElement);\n      } else {\n        for (const child of buildNode(obj[key], key, options)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}