{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\n// We use a custom symbol to cache a reference to the original request without\n// exposing it on the public interface.\nconst originalRequestSymbol = Symbol(\"Original PipelineRequest\");\n// Symbol.for() will return the same symbol if it's already been created\n// This particular one is used in core-client to handle the case of when a request is\n// cloned but we need to retrieve the OperationSpec and OperationArguments from the\n// original request.\nconst originalClientRequestSymbol = Symbol.for(\"@azure/core-client original request\");\nexport function toPipelineRequest(webResource) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const compatWebResource = webResource;\n  const request = compatWebResource[originalRequestSymbol];\n  const headers = createHttpHeaders(webResource.headers.toJson({\n    preserveCase: true\n  }));\n  if (request) {\n    request.headers = headers;\n    return request;\n  } else {\n    const newRequest = createPipelineRequest({\n      url: webResource.url,\n      method: webResource.method,\n      headers,\n      withCredentials: webResource.withCredentials,\n      timeout: webResource.timeout,\n      requestId: webResource.requestId,\n      abortSignal: webResource.abortSignal,\n      body: webResource.body,\n      formData: webResource.formData,\n      disableKeepAlive: !!webResource.keepAlive,\n      onDownloadProgress: webResource.onDownloadProgress,\n      onUploadProgress: webResource.onUploadProgress,\n      proxySettings: webResource.proxySettings,\n      streamResponseStatusCodes: webResource.streamResponseStatusCodes,\n      agent: webResource.agent\n    });\n    if (options.originalRequest) {\n      newRequest[originalClientRequestSymbol] = options.originalRequest;\n    }\n    return newRequest;\n  }\n}\nexport function toWebResourceLike(request, options) {\n  var _a;\n  const originalRequest = (_a = options === null || options === void 0 ? void 0 : options.originalRequest) !== null && _a !== void 0 ? _a : request;\n  const webResource = {\n    url: request.url,\n    method: request.method,\n    headers: toHttpHeadersLike(request.headers),\n    withCredentials: request.withCredentials,\n    timeout: request.timeout,\n    requestId: request.headers.get(\"x-ms-client-request-id\") || request.requestId,\n    abortSignal: request.abortSignal,\n    body: request.body,\n    formData: request.formData,\n    keepAlive: !!request.disableKeepAlive,\n    onDownloadProgress: request.onDownloadProgress,\n    onUploadProgress: request.onUploadProgress,\n    proxySettings: request.proxySettings,\n    streamResponseStatusCodes: request.streamResponseStatusCodes,\n    agent: request.agent,\n    clone() {\n      throw new Error(\"Cannot clone a non-proxied WebResourceLike\");\n    },\n    prepare() {\n      throw new Error(\"WebResourceLike.prepare() is not supported by @azure/core-http-compat\");\n    },\n    validateRequestProperties() {\n      /** do nothing */\n    }\n  };\n  if (options === null || options === void 0 ? void 0 : options.createProxy) {\n    return new Proxy(webResource, {\n      get(target, prop, receiver) {\n        if (prop === originalRequestSymbol) {\n          return request;\n        } else if (prop === \"clone\") {\n          return () => {\n            return toWebResourceLike(toPipelineRequest(webResource, {\n              originalRequest\n            }), {\n              createProxy: true,\n              originalRequest\n            });\n          };\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n      set(target, prop, value, receiver) {\n        if (prop === \"keepAlive\") {\n          request.disableKeepAlive = !value;\n        }\n        const passThroughProps = [\"url\", \"method\", \"withCredentials\", \"timeout\", \"requestId\", \"abortSignal\", \"body\", \"formData\", \"onDownloadProgress\", \"onUploadProgress\", \"proxySettings\", \"streamResponseStatusCodes\", \"agent\"];\n        if (typeof prop === \"string\" && passThroughProps.includes(prop)) {\n          request[prop] = value;\n        }\n        return Reflect.set(target, prop, value, receiver);\n      }\n    });\n  } else {\n    return webResource;\n  }\n}\n/**\n * Converts HttpHeaders from core-rest-pipeline to look like\n * HttpHeaders from core-http.\n * @param headers - HttpHeaders from core-rest-pipeline\n * @returns HttpHeaders as they looked in core-http\n */\nexport function toHttpHeadersLike(headers) {\n  return new HttpHeaders(headers.toJSON({\n    preserveCase: true\n  }));\n}\n/**\n * A collection of HttpHeaders that can be sent with a HTTP request.\n */\nfunction getHeaderKey(headerName) {\n  return headerName.toLowerCase();\n}\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport class HttpHeaders {\n  constructor(rawHeaders) {\n    this._headersMap = {};\n    if (rawHeaders) {\n      for (const headerName in rawHeaders) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  set(headerName, headerValue) {\n    this._headersMap[getHeaderKey(headerName)] = {\n      name: headerName,\n      value: headerValue.toString()\n    };\n  }\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  get(headerName) {\n    const header = this._headersMap[getHeaderKey(headerName)];\n    return !header ? undefined : header.value;\n  }\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  contains(headerName) {\n    return !!this._headersMap[getHeaderKey(headerName)];\n  }\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  remove(headerName) {\n    const result = this.contains(headerName);\n    delete this._headersMap[getHeaderKey(headerName)];\n    return result;\n  }\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  rawHeaders() {\n    return this.toJson({\n      preserveCase: true\n    });\n  }\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  headersArray() {\n    const headers = [];\n    for (const headerKey in this._headersMap) {\n      headers.push(this._headersMap[headerKey]);\n    }\n    return headers;\n  }\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  headerNames() {\n    const headerNames = [];\n    const headers = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerNames.push(headers[i].name);\n    }\n    return headerNames;\n  }\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  headerValues() {\n    const headerValues = [];\n    const headers = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerValues.push(headers[i].value);\n    }\n    return headerValues;\n  }\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  toJson() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const result = {};\n    if (options.preserveCase) {\n      for (const headerKey in this._headersMap) {\n        const header = this._headersMap[headerKey];\n        result[header.name] = header.value;\n      }\n    } else {\n      for (const headerKey in this._headersMap) {\n        const header = this._headersMap[headerKey];\n        result[getHeaderKey(header.name)] = header.value;\n      }\n    }\n    return result;\n  }\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  toString() {\n    return JSON.stringify(this.toJson({\n      preserveCase: true\n    }));\n  }\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  clone() {\n    const resultPreservingCasing = {};\n    for (const headerKey in this._headersMap) {\n      const header = this._headersMap[headerKey];\n      resultPreservingCasing[header.name] = header.value;\n    }\n    return new HttpHeaders(resultPreservingCasing);\n  }\n}","map":{"version":3,"names":["createHttpHeaders","createPipelineRequest","originalRequestSymbol","Symbol","originalClientRequestSymbol","for","toPipelineRequest","webResource","options","arguments","length","undefined","compatWebResource","request","headers","toJson","preserveCase","newRequest","url","method","withCredentials","timeout","requestId","abortSignal","body","formData","disableKeepAlive","keepAlive","onDownloadProgress","onUploadProgress","proxySettings","streamResponseStatusCodes","agent","originalRequest","toWebResourceLike","_a","toHttpHeadersLike","get","clone","Error","prepare","validateRequestProperties","createProxy","Proxy","target","prop","receiver","Reflect","set","value","passThroughProps","includes","HttpHeaders","toJSON","getHeaderKey","headerName","toLowerCase","constructor","rawHeaders","_headersMap","headerValue","name","toString","header","contains","remove","result","headersArray","headerKey","push","headerNames","i","headerValues","JSON","stringify","resultPreservingCasing"],"sources":["C:\\Users\\rdpro\\Projects\\NW Michigan Watershed Coalition\\client\\node_modules\\@azure\\core-http-compat\\src\\util.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpMethods, ProxySettings } from \"@azure/core-rest-pipeline\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport type { HttpHeaders as HttpHeadersV2, PipelineRequest } from \"@azure/core-rest-pipeline\";\n\n// We use a custom symbol to cache a reference to the original request without\n// exposing it on the public interface.\nconst originalRequestSymbol = Symbol(\"Original PipelineRequest\");\ntype CompatWebResourceLike = WebResourceLike & { [originalRequestSymbol]?: PipelineRequest };\n// Symbol.for() will return the same symbol if it's already been created\n// This particular one is used in core-client to handle the case of when a request is\n// cloned but we need to retrieve the OperationSpec and OperationArguments from the\n// original request.\nconst originalClientRequestSymbol = Symbol.for(\"@azure/core-client original request\");\ntype PipelineRequestWithOriginal = PipelineRequest & {\n  [originalClientRequestSymbol]?: PipelineRequest;\n};\n\nexport function toPipelineRequest(\n  webResource: WebResourceLike,\n  options: {\n    originalRequest?: PipelineRequest;\n  } = {},\n): PipelineRequest {\n  const compatWebResource = webResource as CompatWebResourceLike;\n  const request = compatWebResource[originalRequestSymbol];\n  const headers = createHttpHeaders(webResource.headers.toJson({ preserveCase: true }));\n  if (request) {\n    request.headers = headers;\n    return request;\n  } else {\n    const newRequest = createPipelineRequest({\n      url: webResource.url,\n      method: webResource.method,\n      headers,\n      withCredentials: webResource.withCredentials,\n      timeout: webResource.timeout,\n      requestId: webResource.requestId,\n      abortSignal: webResource.abortSignal,\n      body: webResource.body,\n      formData: webResource.formData,\n      disableKeepAlive: !!webResource.keepAlive,\n      onDownloadProgress: webResource.onDownloadProgress,\n      onUploadProgress: webResource.onUploadProgress,\n      proxySettings: webResource.proxySettings,\n      streamResponseStatusCodes: webResource.streamResponseStatusCodes,\n      agent: webResource.agent,\n    });\n    if (options.originalRequest) {\n      (newRequest as PipelineRequestWithOriginal)[originalClientRequestSymbol] =\n        options.originalRequest;\n    }\n    return newRequest;\n  }\n}\n\nexport function toWebResourceLike(\n  request: PipelineRequest,\n  options?: { createProxy?: boolean; originalRequest?: PipelineRequest },\n): WebResourceLike {\n  const originalRequest = options?.originalRequest ?? request;\n  const webResource: WebResourceLike = {\n    url: request.url,\n    method: request.method,\n    headers: toHttpHeadersLike(request.headers),\n    withCredentials: request.withCredentials,\n    timeout: request.timeout,\n    requestId: request.headers.get(\"x-ms-client-request-id\") || request.requestId,\n    abortSignal: request.abortSignal,\n    body: request.body,\n    formData: request.formData,\n    keepAlive: !!request.disableKeepAlive,\n    onDownloadProgress: request.onDownloadProgress,\n    onUploadProgress: request.onUploadProgress,\n    proxySettings: request.proxySettings,\n    streamResponseStatusCodes: request.streamResponseStatusCodes,\n    agent: request.agent,\n    clone(): WebResourceLike {\n      throw new Error(\"Cannot clone a non-proxied WebResourceLike\");\n    },\n    prepare(): WebResourceLike {\n      throw new Error(\"WebResourceLike.prepare() is not supported by @azure/core-http-compat\");\n    },\n    validateRequestProperties(): void {\n      /** do nothing */\n    },\n  };\n\n  if (options?.createProxy) {\n    return new Proxy(webResource, {\n      get(target, prop, receiver) {\n        if (prop === originalRequestSymbol) {\n          return request;\n        } else if (prop === \"clone\") {\n          return () => {\n            return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {\n              createProxy: true,\n              originalRequest,\n            });\n          };\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n      set(target: any, prop, value, receiver) {\n        if (prop === \"keepAlive\") {\n          request.disableKeepAlive = !value;\n        }\n        const passThroughProps = [\n          \"url\",\n          \"method\",\n          \"withCredentials\",\n          \"timeout\",\n          \"requestId\",\n          \"abortSignal\",\n          \"body\",\n          \"formData\",\n          \"onDownloadProgress\",\n          \"onUploadProgress\",\n          \"proxySettings\",\n          \"streamResponseStatusCodes\",\n          \"agent\",\n        ];\n\n        if (typeof prop === \"string\" && passThroughProps.includes(prop)) {\n          (request as any)[prop] = value;\n        }\n\n        return Reflect.set(target, prop, value, receiver);\n      },\n    });\n  } else {\n    return webResource;\n  }\n}\n\n/**\n * Converts HttpHeaders from core-rest-pipeline to look like\n * HttpHeaders from core-http.\n * @param headers - HttpHeaders from core-rest-pipeline\n * @returns HttpHeaders as they looked in core-http\n */\nexport function toHttpHeadersLike(headers: HttpHeadersV2): HttpHeadersLike {\n  return new HttpHeaders(headers.toJSON({ preserveCase: true }));\n}\n\n/**\n * A collection of HttpHeaders that can be sent with a HTTP request.\n */\nfunction getHeaderKey(headerName: string): string {\n  return headerName.toLowerCase();\n}\n\n/**\n * An individual header within a HttpHeaders collection.\n */\nexport interface HttpHeader {\n  /**\n   * The name of the header.\n   */\n  name: string;\n\n  /**\n   * The value of the header.\n   */\n  value: string;\n}\n\n/**\n * A HttpHeaders collection represented as a simple JSON object.\n */\nexport type RawHttpHeaders = { [headerName: string]: string };\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport interface HttpHeadersLike {\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  set(headerName: string, headerValue: string | number): void;\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  get(headerName: string): string | undefined;\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  contains(headerName: string): boolean;\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  remove(headerName: string): boolean;\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  rawHeaders(): RawHttpHeaders;\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  headersArray(): HttpHeader[];\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  headerNames(): string[];\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  headerValues(): string[];\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  clone(): HttpHeadersLike;\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   * The result is the same as `rawHeaders()`.\n   */\n  toJson(options?: { preserveCase?: boolean }): RawHttpHeaders;\n}\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport class HttpHeaders implements HttpHeadersLike {\n  private readonly _headersMap: { [headerKey: string]: HttpHeader };\n\n  constructor(rawHeaders?: RawHttpHeaders) {\n    this._headersMap = {};\n    if (rawHeaders) {\n      for (const headerName in rawHeaders) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  public set(headerName: string, headerValue: string | number): void {\n    this._headersMap[getHeaderKey(headerName)] = {\n      name: headerName,\n      value: headerValue.toString(),\n    };\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  public get(headerName: string): string | undefined {\n    const header: HttpHeader = this._headersMap[getHeaderKey(headerName)];\n    return !header ? undefined : header.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  public contains(headerName: string): boolean {\n    return !!this._headersMap[getHeaderKey(headerName)];\n  }\n\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  public remove(headerName: string): boolean {\n    const result: boolean = this.contains(headerName);\n    delete this._headersMap[getHeaderKey(headerName)];\n    return result;\n  }\n\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  public rawHeaders(): RawHttpHeaders {\n    return this.toJson({ preserveCase: true });\n  }\n\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  public headersArray(): HttpHeader[] {\n    const headers: HttpHeader[] = [];\n    for (const headerKey in this._headersMap) {\n      headers.push(this._headersMap[headerKey]);\n    }\n    return headers;\n  }\n\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  public headerNames(): string[] {\n    const headerNames: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerNames.push(headers[i].name);\n    }\n    return headerNames;\n  }\n\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  public headerValues(): string[] {\n    const headerValues: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerValues.push(headers[i].value);\n    }\n    return headerValues;\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJson(options: { preserveCase?: boolean } = {}): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    if (options.preserveCase) {\n      for (const headerKey in this._headersMap) {\n        const header: HttpHeader = this._headersMap[headerKey];\n        result[header.name] = header.value;\n      }\n    } else {\n      for (const headerKey in this._headersMap) {\n        const header: HttpHeader = this._headersMap[headerKey];\n        result[getHeaderKey(header.name)] = header.value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJson({ preserveCase: true }));\n  }\n\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  public clone(): HttpHeaders {\n    const resultPreservingCasing: RawHttpHeaders = {};\n    for (const headerKey in this._headersMap) {\n      const header: HttpHeader = this._headersMap[headerKey];\n      resultPreservingCasing[header.name] = header.value;\n    }\n    return new HttpHeaders(resultPreservingCasing);\n  }\n}\n\n/**\n * An interface compatible with NodeJS's `http.Agent`.\n * We want to avoid publicly re-exporting the actual interface,\n * since it might vary across runtime versions.\n */\nexport interface Agent {\n  /**\n   * Destroy any sockets that are currently in use by the agent.\n   */\n  destroy(): void;\n  /**\n   * For agents with keepAlive enabled, this sets the maximum number of sockets that will be left open in the free state.\n   */\n  maxFreeSockets: number;\n  /**\n   * Determines how many concurrent sockets the agent can have open per origin.\n   */\n  maxSockets: number;\n  /**\n   * An object which contains queues of requests that have not yet been assigned to sockets.\n   */\n  requests: unknown;\n  /**\n   * An object which contains arrays of sockets currently in use by the agent.\n   */\n  sockets: unknown;\n}\n\n/**\n * A description of a HTTP request to be made to a remote server.\n */\nexport interface WebResourceLike {\n  /**\n   * The URL being accessed by the request.\n   */\n  url: string;\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method: HttpMethods;\n  /**\n   * The HTTP body contents of the request.\n   */\n  body?: any;\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers: HttpHeadersLike;\n  /**\n   * Whether or not the body of the HttpOperationResponse should be treated as a stream.\n   * @deprecated Use streamResponseStatusCodes property instead.\n   */\n  streamResponseBody?: boolean;\n  /**\n   * A list of response status codes whose corresponding HttpOperationResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n  /**\n   * Form data, used to build the request body.\n   */\n  formData?: any;\n  /**\n   * A query string represented as an object.\n   */\n  query?: { [key: string]: any };\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   */\n  withCredentials: boolean;\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   */\n  timeout: number;\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If the connection should be reused.\n   */\n  keepAlive?: boolean;\n  /**\n   * Whether or not to decompress response according to Accept-Encoding header (node-fetch only)\n   */\n  decompressResponse?: boolean;\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId: string;\n\n  /**\n   * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * NODEJS ONLY\n   *\n   * A Node-only option to provide a custom `http.Agent`/`https.Agent`.\n   * NOTE: usually this should be one instance shared by multiple requests so that the underlying\n   *       connection to the service can be reused.\n   * Does nothing when running in the browser.\n   */\n  agent?: Agent;\n\n  /**\n   * Clone this request object.\n   */\n  clone(): WebResourceLike;\n\n  /**\n   * Validates that the required properties such as method, url, headers[\"Content-Type\"],\n   * headers[\"accept-language\"] are defined. It will throw an error if one of the above\n   * mentioned properties are not defined.\n   * Note: this a no-op for compat purposes.\n   */\n  validateRequestProperties(): void;\n\n  /**\n   * This is a no-op for compat purposes and will throw if called.\n   */\n  prepare(options: unknown): WebResourceLike;\n}\n\n/**\n * Fired in response to upload or download progress.\n */\nexport type TransferProgressEvent = {\n  /**\n   * The number of bytes loaded so far.\n   */\n  loadedBytes: number;\n};\n"],"mappings":"AAAA;AACA;AAGA,SAASA,iBAAiB,EAAEC,qBAAqB,QAAQ,2BAA2B;AAIpF;AACA;AACA,MAAMC,qBAAqB,GAAGC,MAAM,CAAC,0BAA0B,CAAC;AAEhE;AACA;AACA;AACA;AACA,MAAMC,2BAA2B,GAAGD,MAAM,CAACE,GAAG,CAAC,qCAAqC,CAAC;AAKrF,OAAM,SAAUC,iBAAiBA,CAC/BC,WAA4B,EAGtB;EAAA,IAFNC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAEI,EAAE;EAEN,MAAMG,iBAAiB,GAAGL,WAAoC;EAC9D,MAAMM,OAAO,GAAGD,iBAAiB,CAACV,qBAAqB,CAAC;EACxD,MAAMY,OAAO,GAAGd,iBAAiB,CAACO,WAAW,CAACO,OAAO,CAACC,MAAM,CAAC;IAAEC,YAAY,EAAE;EAAI,CAAE,CAAC,CAAC;EACrF,IAAIH,OAAO,EAAE;IACXA,OAAO,CAACC,OAAO,GAAGA,OAAO;IACzB,OAAOD,OAAO;EAChB,CAAC,MAAM;IACL,MAAMI,UAAU,GAAGhB,qBAAqB,CAAC;MACvCiB,GAAG,EAAEX,WAAW,CAACW,GAAG;MACpBC,MAAM,EAAEZ,WAAW,CAACY,MAAM;MAC1BL,OAAO;MACPM,eAAe,EAAEb,WAAW,CAACa,eAAe;MAC5CC,OAAO,EAAEd,WAAW,CAACc,OAAO;MAC5BC,SAAS,EAAEf,WAAW,CAACe,SAAS;MAChCC,WAAW,EAAEhB,WAAW,CAACgB,WAAW;MACpCC,IAAI,EAAEjB,WAAW,CAACiB,IAAI;MACtBC,QAAQ,EAAElB,WAAW,CAACkB,QAAQ;MAC9BC,gBAAgB,EAAE,CAAC,CAACnB,WAAW,CAACoB,SAAS;MACzCC,kBAAkB,EAAErB,WAAW,CAACqB,kBAAkB;MAClDC,gBAAgB,EAAEtB,WAAW,CAACsB,gBAAgB;MAC9CC,aAAa,EAAEvB,WAAW,CAACuB,aAAa;MACxCC,yBAAyB,EAAExB,WAAW,CAACwB,yBAAyB;MAChEC,KAAK,EAAEzB,WAAW,CAACyB;KACpB,CAAC;IACF,IAAIxB,OAAO,CAACyB,eAAe,EAAE;MAC1BhB,UAA0C,CAACb,2BAA2B,CAAC,GACtEI,OAAO,CAACyB,eAAe;IAC3B;IACA,OAAOhB,UAAU;EACnB;AACF;AAEA,OAAM,SAAUiB,iBAAiBA,CAC/BrB,OAAwB,EACxBL,OAAsE;;EAEtE,MAAMyB,eAAe,GAAG,CAAAE,EAAA,GAAA3B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEyB,eAAe,cAAAE,EAAA,cAAAA,EAAA,GAAItB,OAAO;EAC3D,MAAMN,WAAW,GAAoB;IACnCW,GAAG,EAAEL,OAAO,CAACK,GAAG;IAChBC,MAAM,EAAEN,OAAO,CAACM,MAAM;IACtBL,OAAO,EAAEsB,iBAAiB,CAACvB,OAAO,CAACC,OAAO,CAAC;IAC3CM,eAAe,EAAEP,OAAO,CAACO,eAAe;IACxCC,OAAO,EAAER,OAAO,CAACQ,OAAO;IACxBC,SAAS,EAAET,OAAO,CAACC,OAAO,CAACuB,GAAG,CAAC,wBAAwB,CAAC,IAAIxB,OAAO,CAACS,SAAS;IAC7EC,WAAW,EAAEV,OAAO,CAACU,WAAW;IAChCC,IAAI,EAAEX,OAAO,CAACW,IAAI;IAClBC,QAAQ,EAAEZ,OAAO,CAACY,QAAQ;IAC1BE,SAAS,EAAE,CAAC,CAACd,OAAO,CAACa,gBAAgB;IACrCE,kBAAkB,EAAEf,OAAO,CAACe,kBAAkB;IAC9CC,gBAAgB,EAAEhB,OAAO,CAACgB,gBAAgB;IAC1CC,aAAa,EAAEjB,OAAO,CAACiB,aAAa;IACpCC,yBAAyB,EAAElB,OAAO,CAACkB,yBAAyB;IAC5DC,KAAK,EAAEnB,OAAO,CAACmB,KAAK;IACpBM,KAAKA,CAAA;MACH,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;IAC/D,CAAC;IACDC,OAAOA,CAAA;MACL,MAAM,IAAID,KAAK,CAAC,uEAAuE,CAAC;IAC1F,CAAC;IACDE,yBAAyBA,CAAA;MACvB;IAAA;GAEH;EAED,IAAIjC,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEkC,WAAW,EAAE;IACxB,OAAO,IAAIC,KAAK,CAACpC,WAAW,EAAE;MAC5B8B,GAAGA,CAACO,MAAM,EAAEC,IAAI,EAAEC,QAAQ;QACxB,IAAID,IAAI,KAAK3C,qBAAqB,EAAE;UAClC,OAAOW,OAAO;QAChB,CAAC,MAAM,IAAIgC,IAAI,KAAK,OAAO,EAAE;UAC3B,OAAO,MAAK;YACV,OAAOX,iBAAiB,CAAC5B,iBAAiB,CAACC,WAAW,EAAE;cAAE0B;YAAe,CAAE,CAAC,EAAE;cAC5ES,WAAW,EAAE,IAAI;cACjBT;aACD,CAAC;UACJ,CAAC;QACH;QACA,OAAOc,OAAO,CAACV,GAAG,CAACO,MAAM,EAAEC,IAAI,EAAEC,QAAQ,CAAC;MAC5C,CAAC;MACDE,GAAGA,CAACJ,MAAW,EAAEC,IAAI,EAAEI,KAAK,EAAEH,QAAQ;QACpC,IAAID,IAAI,KAAK,WAAW,EAAE;UACxBhC,OAAO,CAACa,gBAAgB,GAAG,CAACuB,KAAK;QACnC;QACA,MAAMC,gBAAgB,GAAG,CACvB,KAAK,EACL,QAAQ,EACR,iBAAiB,EACjB,SAAS,EACT,WAAW,EACX,aAAa,EACb,MAAM,EACN,UAAU,EACV,oBAAoB,EACpB,kBAAkB,EAClB,eAAe,EACf,2BAA2B,EAC3B,OAAO,CACR;QAED,IAAI,OAAOL,IAAI,KAAK,QAAQ,IAAIK,gBAAgB,CAACC,QAAQ,CAACN,IAAI,CAAC,EAAE;UAC9DhC,OAAe,CAACgC,IAAI,CAAC,GAAGI,KAAK;QAChC;QAEA,OAAOF,OAAO,CAACC,GAAG,CAACJ,MAAM,EAAEC,IAAI,EAAEI,KAAK,EAAEH,QAAQ,CAAC;MACnD;KACD,CAAC;EACJ,CAAC,MAAM;IACL,OAAOvC,WAAW;EACpB;AACF;AAEA;;;;;;AAMA,OAAM,SAAU6B,iBAAiBA,CAACtB,OAAsB;EACtD,OAAO,IAAIsC,WAAW,CAACtC,OAAO,CAACuC,MAAM,CAAC;IAAErC,YAAY,EAAE;EAAI,CAAE,CAAC,CAAC;AAChE;AAEA;;;AAGA,SAASsC,YAAYA,CAACC,UAAkB;EACtC,OAAOA,UAAU,CAACC,WAAW,EAAE;AACjC;AA4EA;;;AAGA,OAAM,MAAOJ,WAAW;EAGtBK,YAAYC,UAA2B;IACrC,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAID,UAAU,EAAE;MACd,KAAK,MAAMH,UAAU,IAAIG,UAAU,EAAE;QACnC,IAAI,CAACV,GAAG,CAACO,UAAU,EAAEG,UAAU,CAACH,UAAU,CAAC,CAAC;MAC9C;IACF;EACF;EAEA;;;;;;EAMOP,GAAGA,CAACO,UAAkB,EAAEK,WAA4B;IACzD,IAAI,CAACD,WAAW,CAACL,YAAY,CAACC,UAAU,CAAC,CAAC,GAAG;MAC3CM,IAAI,EAAEN,UAAU;MAChBN,KAAK,EAAEW,WAAW,CAACE,QAAQ;KAC5B;EACH;EAEA;;;;;EAKOzB,GAAGA,CAACkB,UAAkB;IAC3B,MAAMQ,MAAM,GAAe,IAAI,CAACJ,WAAW,CAACL,YAAY,CAACC,UAAU,CAAC,CAAC;IACrE,OAAO,CAACQ,MAAM,GAAGpD,SAAS,GAAGoD,MAAM,CAACd,KAAK;EAC3C;EAEA;;;EAGOe,QAAQA,CAACT,UAAkB;IAChC,OAAO,CAAC,CAAC,IAAI,CAACI,WAAW,CAACL,YAAY,CAACC,UAAU,CAAC,CAAC;EACrD;EAEA;;;;;EAKOU,MAAMA,CAACV,UAAkB;IAC9B,MAAMW,MAAM,GAAY,IAAI,CAACF,QAAQ,CAACT,UAAU,CAAC;IACjD,OAAO,IAAI,CAACI,WAAW,CAACL,YAAY,CAACC,UAAU,CAAC,CAAC;IACjD,OAAOW,MAAM;EACf;EAEA;;;EAGOR,UAAUA,CAAA;IACf,OAAO,IAAI,CAAC3C,MAAM,CAAC;MAAEC,YAAY,EAAE;IAAI,CAAE,CAAC;EAC5C;EAEA;;;EAGOmD,YAAYA,CAAA;IACjB,MAAMrD,OAAO,GAAiB,EAAE;IAChC,KAAK,MAAMsD,SAAS,IAAI,IAAI,CAACT,WAAW,EAAE;MACxC7C,OAAO,CAACuD,IAAI,CAAC,IAAI,CAACV,WAAW,CAACS,SAAS,CAAC,CAAC;IAC3C;IACA,OAAOtD,OAAO;EAChB;EAEA;;;EAGOwD,WAAWA,CAAA;IAChB,MAAMA,WAAW,GAAa,EAAE;IAChC,MAAMxD,OAAO,GAAiB,IAAI,CAACqD,YAAY,EAAE;IACjD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzD,OAAO,CAACJ,MAAM,EAAE,EAAE6D,CAAC,EAAE;MACvCD,WAAW,CAACD,IAAI,CAACvD,OAAO,CAACyD,CAAC,CAAC,CAACV,IAAI,CAAC;IACnC;IACA,OAAOS,WAAW;EACpB;EAEA;;;EAGOE,YAAYA,CAAA;IACjB,MAAMA,YAAY,GAAa,EAAE;IACjC,MAAM1D,OAAO,GAAiB,IAAI,CAACqD,YAAY,EAAE;IACjD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzD,OAAO,CAACJ,MAAM,EAAE,EAAE6D,CAAC,EAAE;MACvCC,YAAY,CAACH,IAAI,CAACvD,OAAO,CAACyD,CAAC,CAAC,CAACtB,KAAK,CAAC;IACrC;IACA,OAAOuB,YAAY;EACrB;EAEA;;;EAGOzD,MAAMA,CAAA,EAAyC;IAAA,IAAxCP,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAsC,EAAE;IACpD,MAAMyD,MAAM,GAAmB,EAAE;IACjC,IAAI1D,OAAO,CAACQ,YAAY,EAAE;MACxB,KAAK,MAAMoD,SAAS,IAAI,IAAI,CAACT,WAAW,EAAE;QACxC,MAAMI,MAAM,GAAe,IAAI,CAACJ,WAAW,CAACS,SAAS,CAAC;QACtDF,MAAM,CAACH,MAAM,CAACF,IAAI,CAAC,GAAGE,MAAM,CAACd,KAAK;MACpC;IACF,CAAC,MAAM;MACL,KAAK,MAAMmB,SAAS,IAAI,IAAI,CAACT,WAAW,EAAE;QACxC,MAAMI,MAAM,GAAe,IAAI,CAACJ,WAAW,CAACS,SAAS,CAAC;QACtDF,MAAM,CAACZ,YAAY,CAACS,MAAM,CAACF,IAAI,CAAC,CAAC,GAAGE,MAAM,CAACd,KAAK;MAClD;IACF;IACA,OAAOiB,MAAM;EACf;EAEA;;;EAGOJ,QAAQA,CAAA;IACb,OAAOW,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC3D,MAAM,CAAC;MAAEC,YAAY,EAAE;IAAI,CAAE,CAAC,CAAC;EAC5D;EAEA;;;EAGOsB,KAAKA,CAAA;IACV,MAAMqC,sBAAsB,GAAmB,EAAE;IACjD,KAAK,MAAMP,SAAS,IAAI,IAAI,CAACT,WAAW,EAAE;MACxC,MAAMI,MAAM,GAAe,IAAI,CAACJ,WAAW,CAACS,SAAS,CAAC;MACtDO,sBAAsB,CAACZ,MAAM,CAACF,IAAI,CAAC,GAAGE,MAAM,CAACd,KAAK;IACpD;IACA,OAAO,IAAIG,WAAW,CAACuB,sBAAsB,CAAC;EAChD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}