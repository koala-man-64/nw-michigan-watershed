{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { BlobSASPermissions } from \"./BlobSASPermissions\";\nimport { ContainerSASPermissions } from \"./ContainerSASPermissions\";\nimport { StorageSharedKeyCredential } from \"../credentials/StorageSharedKeyCredential\";\nimport { UserDelegationKeyCredential } from \"../credentials/UserDelegationKeyCredential\";\nimport { ipRangeToString } from \"./SasIPRange\";\nimport { SASQueryParameters } from \"./SASQueryParameters\";\nimport { SERVICE_VERSION } from \"../utils/constants\";\nimport { truncatedISO8061Date } from \"../utils/utils.common\";\nexport function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {\n  return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;\n}\nexport function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n  const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : undefined;\n  let userDelegationKeyCredential;\n  if (sharedKeyCredential === undefined && accountName !== undefined) {\n    userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);\n  }\n  if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {\n    throw TypeError(\"Invalid sharedKeyCredential, userDelegationKey or accountName.\");\n  }\n  // Version 2020-12-06 adds support for encryptionscope in SAS.\n  if (version >= \"2020-12-06\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);\n    }\n  }\n  // Version 2019-12-12 adds support for the blob tags permission.\n  // Version 2018-11-09 adds support for the signed resource and signed blob snapshot time fields.\n  // https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas#constructing-the-signature-string\n  if (version >= \"2018-11-09\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      // Version 2020-02-10 delegation SAS signature construction includes preauthorizedAgentObjectId, agentObjectId, correlationId.\n      if (version >= \"2020-02-10\") {\n        return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);\n      } else {\n        return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);\n      }\n    }\n  }\n  if (version >= \"2015-04-05\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      throw new RangeError(\"'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.\");\n    }\n  }\n  throw new RangeError(\"'version' must be >= '2015-04-05'.\");\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2015-04-05 AND BEFORE 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n  if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\");\n  }\n  let resource = \"c\";\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n  }\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  }\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), blobSASSignatureValues.identifier, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\", blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\", blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\", blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\", blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\"].join(\"\\n\");\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),\n    stringToSign: stringToSign\n  };\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n  if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\");\n  }\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  }\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), blobSASSignatureValues.identifier, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\", blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\", blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\", blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\", blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\"].join(\"\\n\");\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),\n    stringToSign: stringToSign\n  };\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n  if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\");\n  }\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  }\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), blobSASSignatureValues.identifier, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.encryptionScope, blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\", blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\", blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\", blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\", blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\"].join(\"\\n\");\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, undefined, undefined, undefined, blobSASSignatureValues.encryptionScope),\n    stringToSign: stringToSign\n  };\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\");\n  }\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  }\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), userDelegationKeyCredential.userDelegationKey.signedObjectId, userDelegationKeyCredential.userDelegationKey.signedTenantId, userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedService, userDelegationKeyCredential.userDelegationKey.signedVersion, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType].join(\"\\n\");\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),\n    stringToSign: stringToSign\n  };\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-02-10.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\");\n  }\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  }\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), userDelegationKeyCredential.userDelegationKey.signedObjectId, userDelegationKeyCredential.userDelegationKey.signedTenantId, userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedService, userDelegationKeyCredential.userDelegationKey.signedVersion, blobSASSignatureValues.preauthorizedAgentObjectId, undefined,\n  // agentObjectId\n  blobSASSignatureValues.correlationId, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType].join(\"\\n\");\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),\n    stringToSign: stringToSign\n  };\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\");\n  }\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  }\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), userDelegationKeyCredential.userDelegationKey.signedObjectId, userDelegationKeyCredential.userDelegationKey.signedTenantId, userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedService, userDelegationKeyCredential.userDelegationKey.signedVersion, blobSASSignatureValues.preauthorizedAgentObjectId, undefined,\n  // agentObjectId\n  blobSASSignatureValues.correlationId, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.encryptionScope, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType].join(\"\\n\");\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),\n    stringToSign: stringToSign\n  };\n}\nfunction getCanonicalName(accountName, containerName, blobName) {\n  // Container: \"/blob/account/containerName\"\n  // Blob:      \"/blob/account/containerName/blobName\"\n  const elements = [`/blob/${accountName}/${containerName}`];\n  if (blobName) {\n    elements.push(`/${blobName}`);\n  }\n  return elements.join(\"\");\n}\nfunction SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n  if (blobSASSignatureValues.snapshotTime && version < \"2018-11-09\") {\n    throw RangeError(\"'version' must be >= '2018-11-09' when providing 'snapshotTime'.\");\n  }\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {\n    throw RangeError(\"Must provide 'blobName' when providing 'snapshotTime'.\");\n  }\n  if (blobSASSignatureValues.versionId && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'versionId'.\");\n  }\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {\n    throw RangeError(\"Must provide 'blobName' when providing 'versionId'.\");\n  }\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version < \"2020-08-04\") {\n    throw RangeError(\"'version' must be >= '2020-08-04' when provided 'i' permission.\");\n  }\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'x' permission.\");\n  }\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'y' permission.\");\n  }\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version < \"2019-12-12\") {\n    throw RangeError(\"'version' must be >= '2019-12-12' when providing 't' permission.\");\n  }\n  if (version < \"2020-02-10\" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {\n    throw RangeError(\"'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.\");\n  }\n  if (version < \"2021-04-10\" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {\n    throw RangeError(\"'version' must be >= '2021-04-10' when providing the 'f' permission.\");\n  }\n  if (version < \"2020-02-10\" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {\n    throw RangeError(\"'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.\");\n  }\n  if (blobSASSignatureValues.encryptionScope && version < \"2020-12-06\") {\n    throw RangeError(\"'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.\");\n  }\n  blobSASSignatureValues.version = version;\n  return blobSASSignatureValues;\n}","map":{"version":3,"names":["BlobSASPermissions","ContainerSASPermissions","StorageSharedKeyCredential","UserDelegationKeyCredential","ipRangeToString","SASQueryParameters","SERVICE_VERSION","truncatedISO8061Date","generateBlobSASQueryParameters","blobSASSignatureValues","sharedKeyCredentialOrUserDelegationKey","accountName","generateBlobSASQueryParametersInternal","sasQueryParameters","version","sharedKeyCredential","undefined","userDelegationKeyCredential","TypeError","generateBlobSASQueryParameters20201206","generateBlobSASQueryParametersUDK20201206","generateBlobSASQueryParameters20181109","generateBlobSASQueryParametersUDK20200210","generateBlobSASQueryParametersUDK20181109","generateBlobSASQueryParameters20150405","RangeError","SASSignatureValuesSanityCheckAndAutofill","identifier","permissions","expiresOn","resource","blobName","verifiedPermissions","parse","toString","stringToSign","startsOn","getCanonicalName","containerName","ipRange","protocol","cacheControl","contentDisposition","contentEncoding","contentLanguage","contentType","join","signature","computeHMACSHA256","timestamp","snapshotTime","versionId","encryptionScope","userDelegationKey","signedObjectId","signedTenantId","signedStartsOn","signedExpiresOn","signedService","signedVersion","preauthorizedAgentObjectId","correlationId","elements","push","setImmutabilityPolicy","deleteVersion","permanentDelete","tag","move","execute","filterByTags"],"sources":["C:\\Users\\rdpro\\Projects\\NW Michigan Watershed Coalition\\dashboard\\node_modules\\@azure\\storage-blob\\src\\sas\\BlobSASSignatureValues.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { BlobSASPermissions } from \"./BlobSASPermissions\";\nimport type { UserDelegationKey } from \"../BlobServiceClient\";\nimport { ContainerSASPermissions } from \"./ContainerSASPermissions\";\nimport { StorageSharedKeyCredential } from \"../credentials/StorageSharedKeyCredential\";\nimport { UserDelegationKeyCredential } from \"../credentials/UserDelegationKeyCredential\";\nimport type { SasIPRange } from \"./SasIPRange\";\nimport { ipRangeToString } from \"./SasIPRange\";\nimport type { SASProtocol } from \"./SASQueryParameters\";\nimport { SASQueryParameters } from \"./SASQueryParameters\";\nimport { SERVICE_VERSION } from \"../utils/constants\";\nimport { truncatedISO8061Date } from \"../utils/utils.common\";\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * BlobSASSignatureValues is used to help generating Blob service SAS tokens for containers or blobs.\n */\nexport interface BlobSASSignatureValues {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols, HTTPS only or HTTPSandHTTP\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n\n  /**\n   * Optional only when identifier is provided. The time after which the SAS will no longer work.\n   */\n  expiresOn?: Date;\n\n  /**\n   * Optional only when identifier is provided.\n   * Please refer to either {@link ContainerSASPermissions} or {@link BlobSASPermissions} depending on the resource\n   * being accessed for help constructing the permissions string.\n   */\n  permissions?: BlobSASPermissions | ContainerSASPermissions;\n\n  /**\n   * Optional. IP ranges allowed in this SAS.\n   */\n  ipRange?: SasIPRange;\n\n  /**\n   * The name of the container the SAS user may access.\n   */\n  containerName: string;\n\n  /**\n   * Optional. The blob name of the SAS user may access. Required if snapshotTime or versionId is provided.\n   */\n  blobName?: string;\n\n  /**\n   * Optional. Snapshot timestamp string the SAS user may access. Only supported from API version 2018-11-09.\n   */\n  snapshotTime?: string;\n\n  /**\n   * Optional. VersionId of the blob version the SAS user may access. Only supported from API version 2019-10-10.\n   */\n  versionId?: string;\n\n  /**\n   * Optional. The name of the access policy on the container this SAS references if any.\n   *\n   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy\n   */\n  identifier?: string;\n\n  /**\n   * Optional. Encryption scope to use when sending requests authorized with this SAS URI.\n   */\n  encryptionScope?: string;\n\n  /**\n   * Optional. The cache-control header for the SAS.\n   */\n  cacheControl?: string;\n\n  /**\n   * Optional. The content-disposition header for the SAS.\n   */\n  contentDisposition?: string;\n\n  /**\n   * Optional. The content-encoding header for the SAS.\n   */\n  contentEncoding?: string;\n\n  /**\n   * Optional. The content-language header for the SAS.\n   */\n  contentLanguage?: string;\n\n  /**\n   * Optional. The content-type header for the SAS.\n   */\n  contentType?: string;\n\n  /**\n   * Optional. Beginning in version 2020-02-10, specifies the Authorized AAD Object ID in GUID format. The AAD Object ID of a user\n   * authorized by the owner of the user delegation key to perform the action granted by the SAS. The Azure Storage service will\n   * ensure that the owner of the user delegation key has the required permissions before granting access but no additional permission\n   * check for the user specified in this value will be performed. This is only used for User Delegation SAS.\n   */\n  preauthorizedAgentObjectId?: string;\n\n  /**\n   * Optional. Beginning in version 2020-02-10, this is a GUID value that will be logged in the storage diagnostic logs and can be used to\n   * correlate SAS generation with storage resource access. This is only used for User Delegation SAS.\n   */\n  correlationId?: string;\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * Fill in the required details before running the following snippets.\n *\n * Example usage:\n *\n * ```js\n * // Generate service level SAS for a container\n * const containerSAS = generateBlobSASQueryParameters({\n *     containerName, // Required\n *     permissions: ContainerSASPermissions.parse(\"racwdl\"), // Required\n *     startsOn: new Date(), // Optional\n *     expiresOn: new Date(new Date().valueOf() + 86400 * 1000), // Required. Date type\n *     ipRange: { start: \"0.0.0.0\", end: \"255.255.255.255\" }, // Optional\n *     protocol: SASProtocol.HttpsAndHttp, // Optional\n *     version: \"2016-05-31\" // Optional\n *   },\n *   sharedKeyCredential // StorageSharedKeyCredential - `new StorageSharedKeyCredential(account, accountKey)`\n * ).toString();\n * ```\n *\n * Example using an identifier:\n *\n * ```js\n * // Generate service level SAS for a container with identifier\n * // startsOn & permissions are optional when identifier is provided\n * const identifier = \"unique-id\";\n * await containerClient.setAccessPolicy(undefined, [\n *   {\n *     accessPolicy: {\n *       expiresOn: new Date(new Date().valueOf() + 86400 * 1000), // Date type\n *       permissions: ContainerSASPermissions.parse(\"racwdl\").toString(),\n *       startsOn: new Date() // Date type\n *     },\n *     id: identifier\n *   }\n * ]);\n *\n * const containerSAS = generateBlobSASQueryParameters(\n *   {\n *     containerName, // Required\n *     identifier // Required\n *   },\n *   sharedKeyCredential // StorageSharedKeyCredential - `new StorageSharedKeyCredential(account, accountKey)`\n * ).toString();\n * ```\n *\n * Example using a blob name:\n *\n * ```js\n * // Generate service level SAS for a blob\n * const blobSAS = generateBlobSASQueryParameters({\n *     containerName, // Required\n *     blobName, // Required\n *     permissions: BlobSASPermissions.parse(\"racwd\"), // Required\n *     startsOn: new Date(), // Optional\n *     expiresOn: new Date(new Date().valueOf() + 86400 * 1000), // Required. Date type\n *     cacheControl: \"cache-control-override\", // Optional\n *     contentDisposition: \"content-disposition-override\", // Optional\n *     contentEncoding: \"content-encoding-override\", // Optional\n *     contentLanguage: \"content-language-override\", // Optional\n *     contentType: \"content-type-override\", // Optional\n *     ipRange: { start: \"0.0.0.0\", end: \"255.255.255.255\" }, // Optional\n *     protocol: SASProtocol.HttpsAndHttp, // Optional\n *     version: \"2016-05-31\" // Optional\n *   },\n *   sharedKeyCredential // StorageSharedKeyCredential - `new StorageSharedKeyCredential(account, accountKey)`\n * ).toString();\n * ```\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nexport function generateBlobSASQueryParameters(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential,\n): SASQueryParameters;\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * Creates an instance of SASQueryParameters.\n * WARNING: identifier will be ignored when generating user delegation SAS, permissions and expiresOn are required.\n *\n * Example usage:\n *\n * ```js\n * // Generate user delegation SAS for a container\n * const userDelegationKey = await blobServiceClient.getUserDelegationKey(startsOn, expiresOn);\n * const containerSAS = generateBlobSASQueryParameters({\n *     containerName, // Required\n *     permissions: ContainerSASPermissions.parse(\"racwdl\"), // Required\n *     startsOn, // Optional. Date type\n *     expiresOn, // Required. Date type\n *     ipRange: { start: \"0.0.0.0\", end: \"255.255.255.255\" }, // Optional\n *     protocol: SASProtocol.HttpsAndHttp, // Optional\n *     version: \"2018-11-09\" // Must greater than or equal to 2018-11-09 to generate user delegation SAS\n *   },\n *   userDelegationKey, // UserDelegationKey\n *   accountName\n * ).toString();\n * ```\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKey - Return value of `blobServiceClient.getUserDelegationKey()`\n * @param accountName -\n */\nexport function generateBlobSASQueryParameters(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKey: UserDelegationKey,\n  accountName: string,\n): SASQueryParameters;\n\nexport function generateBlobSASQueryParameters(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredentialOrUserDelegationKey: StorageSharedKeyCredential | UserDelegationKey,\n  accountName?: string,\n): SASQueryParameters {\n  return generateBlobSASQueryParametersInternal(\n    blobSASSignatureValues,\n    sharedKeyCredentialOrUserDelegationKey,\n    accountName,\n  ).sasQueryParameters;\n}\n\nexport function generateBlobSASQueryParametersInternal(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredentialOrUserDelegationKey: StorageSharedKeyCredential | UserDelegationKey,\n  accountName?: string,\n): { sasQueryParameters: SASQueryParameters; stringToSign: string } {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n\n  const sharedKeyCredential =\n    sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential\n      ? sharedKeyCredentialOrUserDelegationKey\n      : undefined;\n  let userDelegationKeyCredential: UserDelegationKeyCredential | undefined;\n\n  if (sharedKeyCredential === undefined && accountName !== undefined) {\n    userDelegationKeyCredential = new UserDelegationKeyCredential(\n      accountName,\n      sharedKeyCredentialOrUserDelegationKey as UserDelegationKey,\n    );\n  }\n\n  if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {\n    throw TypeError(\"Invalid sharedKeyCredential, userDelegationKey or accountName.\");\n  }\n\n  // Version 2020-12-06 adds support for encryptionscope in SAS.\n  if (version >= \"2020-12-06\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      return generateBlobSASQueryParametersUDK20201206(\n        blobSASSignatureValues,\n        userDelegationKeyCredential!,\n      );\n    }\n  }\n\n  // Version 2019-12-12 adds support for the blob tags permission.\n  // Version 2018-11-09 adds support for the signed resource and signed blob snapshot time fields.\n  // https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas#constructing-the-signature-string\n  if (version >= \"2018-11-09\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      // Version 2020-02-10 delegation SAS signature construction includes preauthorizedAgentObjectId, agentObjectId, correlationId.\n      if (version >= \"2020-02-10\") {\n        return generateBlobSASQueryParametersUDK20200210(\n          blobSASSignatureValues,\n          userDelegationKeyCredential!,\n        );\n      } else {\n        return generateBlobSASQueryParametersUDK20181109(\n          blobSASSignatureValues,\n          userDelegationKeyCredential!,\n        );\n      }\n    }\n  }\n\n  if (version >= \"2015-04-05\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      throw new RangeError(\n        \"'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.\",\n      );\n    }\n  }\n\n  throw new RangeError(\"'version' must be >= '2015-04-05'.\");\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2015-04-05 AND BEFORE 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20150405(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential,\n): { sasQueryParameters: SASQueryParameters; stringToSign: string } {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (\n    !blobSASSignatureValues.identifier &&\n    !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)\n  ) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\",\n    );\n  }\n\n  let resource: string = \"c\";\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      sharedKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName,\n    ),\n    blobSASSignatureValues.identifier,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\",\n    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\",\n    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\",\n    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\",\n    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\",\n  ].join(\"\\n\");\n\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n\n  return {\n    sasQueryParameters: new SASQueryParameters(\n      blobSASSignatureValues.version!,\n      signature,\n      verifiedPermissions,\n      undefined,\n      undefined,\n      blobSASSignatureValues.protocol,\n      blobSASSignatureValues.startsOn,\n      blobSASSignatureValues.expiresOn,\n      blobSASSignatureValues.ipRange,\n      blobSASSignatureValues.identifier,\n      resource,\n      blobSASSignatureValues.cacheControl,\n      blobSASSignatureValues.contentDisposition,\n      blobSASSignatureValues.contentEncoding,\n      blobSASSignatureValues.contentLanguage,\n      blobSASSignatureValues.contentType,\n    ),\n    stringToSign: stringToSign,\n  };\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20181109(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential,\n): { sasQueryParameters: SASQueryParameters; stringToSign: string } {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (\n    !blobSASSignatureValues.identifier &&\n    !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)\n  ) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\",\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      sharedKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName,\n    ),\n    blobSASSignatureValues.identifier,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\",\n    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\",\n    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\",\n    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\",\n    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\",\n  ].join(\"\\n\");\n\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n\n  return {\n    sasQueryParameters: new SASQueryParameters(\n      blobSASSignatureValues.version!,\n      signature,\n      verifiedPermissions,\n      undefined,\n      undefined,\n      blobSASSignatureValues.protocol,\n      blobSASSignatureValues.startsOn,\n      blobSASSignatureValues.expiresOn,\n      blobSASSignatureValues.ipRange,\n      blobSASSignatureValues.identifier,\n      resource,\n      blobSASSignatureValues.cacheControl,\n      blobSASSignatureValues.contentDisposition,\n      blobSASSignatureValues.contentEncoding,\n      blobSASSignatureValues.contentLanguage,\n      blobSASSignatureValues.contentType,\n    ),\n    stringToSign: stringToSign,\n  };\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20201206(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential,\n): { sasQueryParameters: SASQueryParameters; stringToSign: string } {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (\n    !blobSASSignatureValues.identifier &&\n    !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)\n  ) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\",\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      sharedKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName,\n    ),\n    blobSASSignatureValues.identifier,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.encryptionScope,\n    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\",\n    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\",\n    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\",\n    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\",\n    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\",\n  ].join(\"\\n\");\n\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n\n  return {\n    sasQueryParameters: new SASQueryParameters(\n      blobSASSignatureValues.version!,\n      signature,\n      verifiedPermissions,\n      undefined,\n      undefined,\n      blobSASSignatureValues.protocol,\n      blobSASSignatureValues.startsOn,\n      blobSASSignatureValues.expiresOn,\n      blobSASSignatureValues.ipRange,\n      blobSASSignatureValues.identifier,\n      resource,\n      blobSASSignatureValues.cacheControl,\n      blobSASSignatureValues.contentDisposition,\n      blobSASSignatureValues.contentEncoding,\n      blobSASSignatureValues.contentLanguage,\n      blobSASSignatureValues.contentType,\n      undefined,\n      undefined,\n      undefined,\n      blobSASSignatureValues.encryptionScope,\n    ),\n    stringToSign: stringToSign,\n  };\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20181109(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKeyCredential: UserDelegationKeyCredential,\n): { sasQueryParameters: SASQueryParameters; stringToSign: string } {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\",\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      userDelegationKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName,\n    ),\n    userDelegationKeyCredential.userDelegationKey.signedObjectId,\n    userDelegationKeyCredential.userDelegationKey.signedTenantId,\n    userDelegationKeyCredential.userDelegationKey.signedStartsOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedExpiresOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedService,\n    userDelegationKeyCredential.userDelegationKey.signedVersion,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n  ].join(\"\\n\");\n\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(\n      blobSASSignatureValues.version!,\n      signature,\n      verifiedPermissions,\n      undefined,\n      undefined,\n      blobSASSignatureValues.protocol,\n      blobSASSignatureValues.startsOn,\n      blobSASSignatureValues.expiresOn,\n      blobSASSignatureValues.ipRange,\n      blobSASSignatureValues.identifier,\n      resource,\n      blobSASSignatureValues.cacheControl,\n      blobSASSignatureValues.contentDisposition,\n      blobSASSignatureValues.contentEncoding,\n      blobSASSignatureValues.contentLanguage,\n      blobSASSignatureValues.contentType,\n      userDelegationKeyCredential.userDelegationKey,\n    ),\n    stringToSign: stringToSign,\n  };\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-02-10.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20200210(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKeyCredential: UserDelegationKeyCredential,\n): { sasQueryParameters: SASQueryParameters; stringToSign: string } {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\",\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      userDelegationKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName,\n    ),\n    userDelegationKeyCredential.userDelegationKey.signedObjectId,\n    userDelegationKeyCredential.userDelegationKey.signedTenantId,\n    userDelegationKeyCredential.userDelegationKey.signedStartsOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedExpiresOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedService,\n    userDelegationKeyCredential.userDelegationKey.signedVersion,\n    blobSASSignatureValues.preauthorizedAgentObjectId,\n    undefined, // agentObjectId\n    blobSASSignatureValues.correlationId,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n  ].join(\"\\n\");\n\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(\n      blobSASSignatureValues.version!,\n      signature,\n      verifiedPermissions,\n      undefined,\n      undefined,\n      blobSASSignatureValues.protocol,\n      blobSASSignatureValues.startsOn,\n      blobSASSignatureValues.expiresOn,\n      blobSASSignatureValues.ipRange,\n      blobSASSignatureValues.identifier,\n      resource,\n      blobSASSignatureValues.cacheControl,\n      blobSASSignatureValues.contentDisposition,\n      blobSASSignatureValues.contentEncoding,\n      blobSASSignatureValues.contentLanguage,\n      blobSASSignatureValues.contentType,\n      userDelegationKeyCredential.userDelegationKey,\n      blobSASSignatureValues.preauthorizedAgentObjectId,\n      blobSASSignatureValues.correlationId,\n    ),\n    stringToSign: stringToSign,\n  };\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20201206(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKeyCredential: UserDelegationKeyCredential,\n): { sasQueryParameters: SASQueryParameters; stringToSign: string } {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\",\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString(),\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      userDelegationKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName,\n    ),\n    userDelegationKeyCredential.userDelegationKey.signedObjectId,\n    userDelegationKeyCredential.userDelegationKey.signedTenantId,\n    userDelegationKeyCredential.userDelegationKey.signedStartsOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedExpiresOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedService,\n    userDelegationKeyCredential.userDelegationKey.signedVersion,\n    blobSASSignatureValues.preauthorizedAgentObjectId,\n    undefined, // agentObjectId\n    blobSASSignatureValues.correlationId,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.encryptionScope,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n  ].join(\"\\n\");\n\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return {\n    sasQueryParameters: new SASQueryParameters(\n      blobSASSignatureValues.version!,\n      signature,\n      verifiedPermissions,\n      undefined,\n      undefined,\n      blobSASSignatureValues.protocol,\n      blobSASSignatureValues.startsOn,\n      blobSASSignatureValues.expiresOn,\n      blobSASSignatureValues.ipRange,\n      blobSASSignatureValues.identifier,\n      resource,\n      blobSASSignatureValues.cacheControl,\n      blobSASSignatureValues.contentDisposition,\n      blobSASSignatureValues.contentEncoding,\n      blobSASSignatureValues.contentLanguage,\n      blobSASSignatureValues.contentType,\n      userDelegationKeyCredential.userDelegationKey,\n      blobSASSignatureValues.preauthorizedAgentObjectId,\n      blobSASSignatureValues.correlationId,\n      blobSASSignatureValues.encryptionScope,\n    ),\n    stringToSign: stringToSign,\n  };\n}\n\nfunction getCanonicalName(accountName: string, containerName: string, blobName?: string): string {\n  // Container: \"/blob/account/containerName\"\n  // Blob:      \"/blob/account/containerName/blobName\"\n  const elements: string[] = [`/blob/${accountName}/${containerName}`];\n  if (blobName) {\n    elements.push(`/${blobName}`);\n  }\n  return elements.join(\"\");\n}\n\nfunction SASSignatureValuesSanityCheckAndAutofill(\n  blobSASSignatureValues: BlobSASSignatureValues,\n): BlobSASSignatureValues {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n  if (blobSASSignatureValues.snapshotTime && version < \"2018-11-09\") {\n    throw RangeError(\"'version' must be >= '2018-11-09' when providing 'snapshotTime'.\");\n  }\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {\n    throw RangeError(\"Must provide 'blobName' when providing 'snapshotTime'.\");\n  }\n\n  if (blobSASSignatureValues.versionId && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'versionId'.\");\n  }\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {\n    throw RangeError(\"Must provide 'blobName' when providing 'versionId'.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.setImmutabilityPolicy &&\n    version < \"2020-08-04\"\n  ) {\n    throw RangeError(\"'version' must be >= '2020-08-04' when provided 'i' permission.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.deleteVersion &&\n    version < \"2019-10-10\"\n  ) {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'x' permission.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.permanentDelete &&\n    version < \"2019-10-10\"\n  ) {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'y' permission.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.tag &&\n    version < \"2019-12-12\"\n  ) {\n    throw RangeError(\"'version' must be >= '2019-12-12' when providing 't' permission.\");\n  }\n\n  if (\n    version < \"2020-02-10\" &&\n    blobSASSignatureValues.permissions &&\n    (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)\n  ) {\n    throw RangeError(\"'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.\");\n  }\n\n  if (\n    version < \"2021-04-10\" &&\n    blobSASSignatureValues.permissions &&\n    (blobSASSignatureValues.permissions as ContainerSASPermissions).filterByTags\n  ) {\n    throw RangeError(\"'version' must be >= '2021-04-10' when providing the 'f' permission.\");\n  }\n\n  if (\n    version < \"2020-02-10\" &&\n    (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)\n  ) {\n    throw RangeError(\n      \"'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.\",\n    );\n  }\n\n  if (blobSASSignatureValues.encryptionScope && version < \"2020-12-06\") {\n    throw RangeError(\"'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.\");\n  }\n\n  blobSASSignatureValues.version = version;\n  return blobSASSignatureValues;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}