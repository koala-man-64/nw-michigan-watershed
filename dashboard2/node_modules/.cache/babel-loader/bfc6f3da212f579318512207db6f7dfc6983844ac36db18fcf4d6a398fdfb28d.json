{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport { isRestError } from \"../restError.js\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nasync function trySendRequest(request, next) {\n  try {\n    return [await next(request), undefined];\n  } catch (e) {\n    if (isRestError(e) && e.response) {\n      return [e.response, e];\n    } else {\n      throw e;\n    }\n  }\n}\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n  const {\n    scopes,\n    getAccessToken,\n    request\n  } = options;\n  // Enable CAE true by default\n  const getTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n    enableCae: true\n  };\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction isChallengeResponse(response) {\n  return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nasync function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {\n  var _a;\n  const {\n    scopes\n  } = onChallengeOptions;\n  const accessToken = await onChallengeOptions.getAccessToken(scopes, {\n    enableCae: true,\n    claims: caeClaims\n  });\n  if (!accessToken) {\n    return false;\n  }\n  onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n  return true;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a, _b, _c;\n  const {\n    credential,\n    scopes,\n    challengeCallbacks\n  } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest: (_b = (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) === null || _a === void 0 ? void 0 : _a.bind(challengeCallbacks)) !== null && _b !== void 0 ? _b : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: (_c = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) === null || _c === void 0 ? void 0 : _c.bind(challengeCallbacks)\n  };\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential ? createTokenCycler(credential /* , options */) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request, next) {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n      }\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger\n      });\n      let response;\n      let error;\n      let shouldSendRequest;\n      [response, error] = await trySendRequest(request, next);\n      if (isChallengeResponse(response)) {\n        let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n        // Handle CAE by default when receive CAE claim\n        if (claims) {\n          let parsedClaim;\n          // Return the response immediately if claims is not a valid base64 encoded string\n          try {\n            parsedClaim = atob(claims);\n          } catch (e) {\n            logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n            return response;\n          }\n          shouldSendRequest = await authorizeRequestOnCaeChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            response,\n            request,\n            getAccessToken,\n            logger\n          }, parsedClaim);\n          // Send updated request and handle response for RestError\n          if (shouldSendRequest) {\n            [response, error] = await trySendRequest(request, next);\n          }\n        } else if (callbacks.authorizeRequestOnChallenge) {\n          // Handle custom challenges when client provides custom callback\n          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            response,\n            getAccessToken,\n            logger\n          });\n          // Send updated request and handle response for RestError\n          if (shouldSendRequest) {\n            [response, error] = await trySendRequest(request, next);\n          }\n          // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n          if (isChallengeResponse(response)) {\n            claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n            if (claims) {\n              let parsedClaim;\n              try {\n                parsedClaim = atob(claims);\n              } catch (e) {\n                logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                return response;\n              }\n              shouldSendRequest = await authorizeRequestOnCaeChallenge({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                response,\n                request,\n                getAccessToken,\n                logger\n              }, parsedClaim);\n              // Send updated request and handle response for RestError\n              if (shouldSendRequest) {\n                [response, error] = await trySendRequest(request, next);\n              }\n            }\n          }\n        }\n      }\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    }\n  };\n}\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges) {\n  // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n  // The challenge regex captures parameteres with either quotes values or unquoted values\n  const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n  // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n  // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n  const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n  const parsedChallenges = [];\n  let match;\n  // Iterate over each challenge match\n  while ((match = challengeRegex.exec(challenges)) !== null) {\n    const scheme = match[1];\n    const paramsString = match[2];\n    const params = {};\n    let paramMatch;\n    // Iterate over each parameter match\n    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n      params[paramMatch[1]] = paramMatch[2];\n    }\n    parsedChallenges.push({\n      scheme,\n      params\n    });\n  }\n  return parsedChallenges;\n}\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges) {\n  var _a;\n  if (!challenges) {\n    return;\n  }\n  // Find all challenges present in the header\n  const parsedChallenges = parseChallenges(challenges);\n  return (_a = parsedChallenges.find(x => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\")) === null || _a === void 0 ? void 0 : _a.params.claims;\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","isRestError","bearerTokenAuthenticationPolicyName","trySendRequest","request","next","undefined","e","response","defaultAuthorizeRequest","options","scopes","getAccessToken","getTokenOptions","abortSignal","tracingOptions","enableCae","accessToken","headers","set","token","isChallengeResponse","status","has","authorizeRequestOnCaeChallenge","onChallengeOptions","caeClaims","claims","_a","tokenType","bearerTokenAuthenticationPolicy","credential","challengeCallbacks","callbacks","authorizeRequest","_b","bind","authorizeRequestOnChallenge","_c","Promise","resolve","name","sendRequest","url","toLowerCase","startsWith","Error","Array","isArray","error","shouldSendRequest","getCaeChallengeClaims","get","parsedClaim","atob","warning","parseChallenges","challenges","challengeRegex","paramRegex","parsedChallenges","match","exec","scheme","paramsString","params","paramMatch","push","find","x"],"sources":["C:\\Users\\rdpro\\Projects\\NW Michigan Watershed Coalition\\dashboard\\node_modules\\@azure\\core-rest-pipeline\\src\\policies\\bearerTokenAuthenticationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport type { RestError } from \"../restError.js\";\nimport { isRestError } from \"../restError.js\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options sent to the authorizeRequest callback\n */\nexport interface AuthorizeRequestOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options sent to the authorizeRequestOnChallenge callback\n */\nexport interface AuthorizeRequestOnChallengeOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * Response containing the challenge.\n   */\n  response: PipelineResponse;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options to override the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n */\nexport interface ChallengeCallbacks {\n  /**\n   * Allows for the authorization of the main request of this policy before it's sent.\n   */\n  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;\n  /**\n   * Allows to handle authentication challenges and to re-authorize the request.\n   * The response containing the challenge is `options.response`.\n   * If this method returns true, the underlying request will be sent once again.\n   * The request may be modified before being sent.\n   */\n  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;\n}\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential?: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n  /**\n   * Allows for the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.\n   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.\n   */\n  challengeCallbacks?: ChallengeCallbacks;\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nasync function trySendRequest(\n  request: PipelineRequest,\n  next: SendRequest,\n): Promise<[PipelineResponse, RestError | undefined]> {\n  try {\n    return [await next(request), undefined];\n  } catch (e: any) {\n    if (isRestError(e) && e.response) {\n      return [e.response, e];\n    } else {\n      throw e;\n    }\n  }\n}\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {\n  const { scopes, getAccessToken, request } = options;\n  // Enable CAE true by default\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n    enableCae: true,\n  };\n\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction isChallengeResponse(response: PipelineResponse): boolean {\n  return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nasync function authorizeRequestOnCaeChallenge(\n  onChallengeOptions: AuthorizeRequestOnChallengeOptions,\n  caeClaims: string,\n): Promise<boolean> {\n  const { scopes } = onChallengeOptions;\n\n  const accessToken = await onChallengeOptions.getAccessToken(scopes, {\n    enableCae: true,\n    claims: caeClaims,\n  });\n  if (!accessToken) {\n    return false;\n  }\n\n  onChallengeOptions.request.headers.set(\n    \"Authorization\",\n    `${accessToken.tokenType ?? \"Bearer\"} ${accessToken.token}`,\n  );\n  return true;\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions,\n): PipelinePolicy {\n  const { credential, scopes, challengeCallbacks } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest:\n      challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,\n    authorizeRequestOnChallenge:\n      challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks),\n  };\n\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential\n    ? createTokenCycler(credential /* , options */)\n    : () => Promise.resolve(null);\n\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\",\n        );\n      }\n\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger,\n      });\n\n      let response: PipelineResponse;\n      let error: Error | undefined;\n      let shouldSendRequest: boolean;\n      [response, error] = await trySendRequest(request, next);\n\n      if (isChallengeResponse(response)) {\n        let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n        // Handle CAE by default when receive CAE claim\n        if (claims) {\n          let parsedClaim: string;\n          // Return the response immediately if claims is not a valid base64 encoded string\n          try {\n            parsedClaim = atob(claims);\n          } catch (e) {\n            logger.warning(\n              `The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,\n            );\n            return response;\n          }\n          shouldSendRequest = await authorizeRequestOnCaeChallenge(\n            {\n              scopes: Array.isArray(scopes) ? scopes : [scopes],\n              response,\n              request,\n              getAccessToken,\n              logger,\n            },\n            parsedClaim,\n          );\n          // Send updated request and handle response for RestError\n          if (shouldSendRequest) {\n            [response, error] = await trySendRequest(request, next);\n          }\n        } else if (callbacks.authorizeRequestOnChallenge) {\n          // Handle custom challenges when client provides custom callback\n          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            response,\n            getAccessToken,\n            logger,\n          });\n\n          // Send updated request and handle response for RestError\n          if (shouldSendRequest) {\n            [response, error] = await trySendRequest(request, next);\n          }\n\n          // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n          if (isChallengeResponse(response)) {\n            claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\") as string);\n            if (claims) {\n              let parsedClaim: string;\n              try {\n                parsedClaim = atob(claims);\n              } catch (e) {\n                logger.warning(\n                  `The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,\n                );\n                return response;\n              }\n\n              shouldSendRequest = await authorizeRequestOnCaeChallenge(\n                {\n                  scopes: Array.isArray(scopes) ? scopes : [scopes],\n                  response,\n                  request,\n                  getAccessToken,\n                  logger,\n                },\n                parsedClaim,\n              );\n              // Send updated request and handle response for RestError\n              if (shouldSendRequest) {\n                [response, error] = await trySendRequest(request, next);\n              }\n            }\n          }\n        }\n      }\n\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    },\n  };\n}\n\n/**\n *\n * Interface to represent a parsed challenge.\n *\n * @internal\n */\ninterface AuthChallenge {\n  scheme: string;\n  params: Record<string, string>;\n}\n\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges: string): AuthChallenge[] {\n  // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n  // The challenge regex captures parameteres with either quotes values or unquoted values\n  const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n  // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n  // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n  const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n\n  const parsedChallenges: AuthChallenge[] = [];\n  let match;\n\n  // Iterate over each challenge match\n  while ((match = challengeRegex.exec(challenges)) !== null) {\n    const scheme = match[1];\n    const paramsString = match[2];\n    const params: Record<string, string> = {};\n    let paramMatch;\n\n    // Iterate over each parameter match\n    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n      params[paramMatch[1]] = paramMatch[2];\n    }\n\n    parsedChallenges.push({ scheme, params });\n  }\n  return parsedChallenges;\n}\n\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges: string | undefined): string | undefined {\n  if (!challenges) {\n    return;\n  }\n  // Find all challenges present in the header\n  const parsedChallenges = parseChallenges(challenges);\n  return parsedChallenges.find(\n    (x) => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\",\n  )?.params.claims;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}